namespace follow =
  "http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset"
namespace gl = "http://blackmesatech.com/2019/iXML/Gluschkov"
namespace gt = "http://blackmesatech.com/2020/grammartools"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace rtn =
  "http://blackmesatech.com/2020/iXML/recursive-transition-networks"
namespace xs = "http://www.w3.org/2001/XMLSchema"

# Relax NG schema for ixml grammars.
# Based on grammar of 25 January 2022.
#
# Captures structural rules but does not capture all constraints
# on character data or attribute values.
#
# Namespace-qualified attributes are allowed everywhere.


start = ixml
ixml = e.ixml
e.ixml =
  element ixml {
    external-attributes,
    (s,
     (rule, (s, rule)*),
     s)
  }
s = h.s
h.s = (whitespace | comment)*
whitespace = h.whitespace
h.whitespace =
  # alt with no realized children
  empty
  | tab
  | lf
  | cr
tab = h.tab
h.tab =
  # alt with no realized children
  empty
lf = h.lf
h.lf =
  # alt with no realized children
  empty
cr = h.cr
h.cr =
  # alt with no realized children
  empty
comment = e.comment
e.comment = element comment { external-attributes, (cchar | comment)* }
cchar = h.cchar
h.cchar =
  # can a data element be used?
  text
rule = e.rule
e.rule =
  element rule {
    external-attributes,
    ((mark, s)?, name, s, s, h.alts)
  }
mark = a.mark
a.mark =
  attribute mark {
    # can a data element be used?
    text
  }
alts = e.alts
e.alts =
  element alts {
    external-attributes,
    (alt, (s, alt)*)
  }
h.alts = alt, (s, alt)*
alt = e.alt
e.alt =
  element alt {
    external-attributes,
    (term, (s, term)*)?
  }
term = h.term
h.term = factor | option | repeat0 | repeat1
factor = h.factor
h.factor = terminal | nonterminal | (s, alts, s)
repeat0 = e.repeat0
e.repeat0 = element repeat0 { external-attributes, (factor, s, sep?) }
repeat1 = e.repeat1
e.repeat1 = element repeat1 { external-attributes, (factor, s, sep?) }
option = e.option
e.option = element option { external-attributes, (factor, s) }
sep = e.sep
e.sep = element sep { external-attributes, factor }
nonterminal = e.nonterminal
e.nonterminal =
  element nonterminal {
    external-attributes,
    ((mark, s)?, name, s)
  }
terminal = h.terminal
h.terminal = literal | charset
literal = e.literal
e.literal = element literal { external-attributes, (quoted | encoded) }
quoted = h.quoted
h.quoted = (tmark, s)?, \string
name = a.name
a.name = attribute name { namestart, namefollower* }
namestart = h.namestart
h.namestart =
  # can a data element be used?
  text
namefollower = h.namefollower
h.namefollower =
  namestart
  | # can a data element be used?
    text
tmark = a.tmark
a.tmark =
  attribute tmark {
    # can a data element be used?
    text
  }
\string = a.string
a.string =
  attribute string {
    text
    # <rng:choice>
    #    <rng:group>
    #       <rng:oneOrMore>
    #          <rng:ref name="dchar"/>
    #       </rng:oneOrMore>
    #       <rng:ref name="s"/>
    #    </rng:group>
    #    <rng:group>
    #       <rng:oneOrMore>
    #          <rng:ref name="schar"/>
    #       </rng:oneOrMore>
    #       <rng:ref name="s"/>
    #    </rng:group>
    # </rng:choice>
    
  }
dchar = e.dchar
e.dchar =
  element dchar {
    external-attributes,
    (# can a data element be used?
     text
     | # can a data element be used?
       text)
  }
schar = e.schar
e.schar =
  element schar {
    external-attributes,
    (# can a data element be used?
     text
     | # can a data element be used?
       text)
  }
encoded = h.encoded
h.encoded = (tmark, s)?, a.hex, s
hex = e.hex
e.hex =
  element hex {
    external-attributes,
    # can a data element be used?
    text+
  }
a.hex =
  attribute hex {
    # can a data element be used?
    text+
  }
charset = h.charset
h.charset = inclusion | exclusion
inclusion = e.inclusion
e.inclusion =
  element inclusion {
    external-attributes,
    ((tmark, s)?, set)
  }
exclusion = e.exclusion
e.exclusion =
  element exclusion {
    external-attributes,
    ((tmark, s)?, s, set)
  }
set = h.set
h.set =
  s,
  (member, (s, member)*)?,
  s
member = h.member
h.member = literal | range | class
range = e.range
e.range = element range { external-attributes, (from, s, s, to, s) }
from = a.from
a.from =
  attribute from {
    text
    # <rng:group>
    #    <rng:ref name="character"/>
    # </rng:group>
    
  }
to = a.to
a.to =
  attribute to {
    text
    # <rng:group>
    #    <rng:ref name="character"/>
    # </rng:group>
    
  }
character = h.character
h.character =
  dchar
  | schar
  | (# can a data element be used?
     text,
     hex)
class = e.class
e.class = element class { external-attributes, (code, s) }
code = a.code
a.code = attribute code { capital, letter? }
capital = h.capital
h.capital =
  # can a data element be used?
  text
letter = h.letter
h.letter =
  # can a data element be used?
  text
external-attributes = empty
