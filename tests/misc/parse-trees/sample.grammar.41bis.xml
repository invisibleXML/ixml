<ixml><comment> Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
Compilerbaus (Bonn: Addison-Wesley, 1996), pp. 36-37.

Oberon-0.

Rules for ws added for convenience; Wirth assumes the lexer
eats whitespace. </comment><comment> Revisions:
  2022-06-15 : CMSMcQ : revise S handling again (leading ws pattern).
                        Make selector and procedures reject epsilon
                        for clarity in the output
  2022-06-14 : CMSMcQ : revise S handling (tight tags, where possible).
                        Hide most literals, use pre-terminal symbols.
  2018-08-10 : CMSMcQ : correct syntax errors found by DCG parser
  2018-08-09 : CMSMcQ : made first transcription; needs testing, since
      the translation from Wirth's EBNF is error-prone.
</comment><comment> We move the rule for module to the front, since it is the
start symbol. </comment><rule name="module"><alt><option><nonterminal name="S"/></option><literal tmark="-" string="MODULE"/><nonterminal name="S"/><nonterminal mark="@" name="ident"/><literal tmark="-" string=";"/><option><nonterminal name="S"/></option><nonterminal name="declarations"/><option><alts><alt><literal tmark="-" string="BEGIN"/><option><nonterminal name="S"/></option><nonterminal name="StatementSequence"/></alt></alts></option><literal tmark="-" string="END"/><nonterminal name="S"/><nonterminal mark="@" name="ident_close"/><literal tmark="-" string="."/><option><nonterminal name="S"/></option></alt></rule><rule name="ident"><alt><nonterminal name="letter"/><repeat0><alts><alt><nonterminal name="letter"/></alt><alt><nonterminal name="digit"/></alt></alts></repeat0><option><nonterminal name="S"/></option></alt></rule><rule name="ident_close"><alt><nonterminal name="ident"/></alt></rule><rule name="integer"><alt><nonterminal name="digit"/><repeat0><alts><alt><nonterminal name="digit"/></alt></alts></repeat0><option><nonterminal name="S"/></option></alt></rule><rule name="selector"><alt><repeat1><alts><alt><nonterminal name="member"/></alt><alt><nonterminal name="subscript"/></alt></alts></repeat1></alt></rule><rule name="member"><alt><literal tmark="-" string="."/><option><nonterminal name="S"/></option><nonterminal name="ident"/></alt></rule><rule name="subscript"><alt><literal tmark="-" string="["/><option><nonterminal name="S"/></option><nonterminal name="expression"/><literal tmark="-" string="]"/><option><nonterminal name="S"/></option></alt></rule><comment>selector = (".", S?, ident; "[", S?, expression, "]", S?)*.</comment><rule name="number"><alt><nonterminal name="integer"/></alt></rule><rule name="factor"><alt><nonterminal name="ident"/><option><nonterminal name="selector"/></option></alt><alt><nonterminal name="number"/></alt><alt><literal tmark="-" string="("/><option><nonterminal name="S"/></option><nonterminal name="expression"/><literal tmark="-" string=")"/><option><nonterminal name="S"/></option></alt><alt><literal string="~"/><option><nonterminal name="S"/></option><nonterminal name="factor"/></alt></rule><rule name="term"><alt><repeat1><nonterminal name="factor"/><sep><alts><alt><nonterminal name="TIMES"/></alt><alt><nonterminal name="DIV"/></alt><alt><nonterminal name="MOD"/></alt><alt><nonterminal name="AND"/></alt></alts></sep></repeat1></alt></rule><rule name="SimpleExpression"><alt><option><alts><alt><nonterminal name="PLUS"/></alt><alt><nonterminal name="MINUS"/></alt></alts></option><repeat1><nonterminal name="term"/><sep><alts><alt><nonterminal name="PLUS"/></alt><alt><nonterminal name="MINUS"/></alt><alt><nonterminal name="OR"/></alt></alts></sep></repeat1></alt></rule><comment> N.B. Simplexpression allows 1, -1, 1 + 1,
      -1 + 1, but not 1 + -1.
      I expect that's intentional.
      I've made it also forbid white space between sign and term.
    </comment><rule name="expression"><alt><nonterminal name="SimpleExpression"/><option><alts><alt><nonterminal mark="-" name="COMPARATOR"/><nonterminal name="SimpleExpression"/></alt></alts></option></alt></rule><rule mark="-" name="COMPARATOR"><alt><nonterminal name="EQL"/></alt><alt><nonterminal name="NEQ"/></alt><alt><nonterminal name="LSS"/></alt><alt><nonterminal name="LEQ"/></alt><alt><nonterminal name="GTR"/></alt><alt><nonterminal name="GEQ"/></alt></rule><rule name="assignment"><alt><nonterminal name="ident"/><option><nonterminal name="selector"/></option><literal tmark="-" string=":="/><option><nonterminal name="S"/></option><nonterminal name="expression"/></alt></rule><rule name="ActualParameters"><alt><literal tmark="-" string="("/><option><nonterminal name="S"/></option><repeat0><nonterminal name="expression"/><sep><alts><alt><literal tmark="-" string=","/><option><nonterminal name="S"/></option></alt></alts></sep></repeat0><literal tmark="-" string=")"/><option><nonterminal name="S"/></option></alt></rule><rule name="ProcedureCall"><alt><nonterminal name="ident"/><option><nonterminal name="selector"/></option><option><nonterminal name="ActualParameters"/></option></alt></rule><rule name="IfStatement"><alt><literal tmark="-" string="IF"/><option><nonterminal name="S"/></option><nonterminal name="condition"/><literal tmark="-" string="THEN"/><option><nonterminal name="S"/></option><nonterminal name="then-stmts"/><repeat0><alts><alt><literal tmark="-" string="ELSIF"/><option><nonterminal name="S"/></option><nonterminal name="condition"/><literal tmark="-" string="THEN"/><option><nonterminal name="S"/></option><nonterminal name="then-stmts"/></alt></alts></repeat0><option><alts><alt><literal tmark="-" string="ELSE"/><option><nonterminal name="S"/></option><nonterminal name="else-stmts"/></alt></alts></option><literal tmark="-" string="END"/><option><nonterminal name="S"/></option></alt></rule><rule name="condition"><alt><nonterminal mark="-" name="expression"/></alt></rule><rule name="then-stmts"><alt><nonterminal mark="-" name="StatementSequence"/></alt></rule><rule name="else-stmts"><alt><nonterminal mark="-" name="StatementSequence"/></alt></rule><rule name="WhileStatement"><alt><literal tmark="-" string="WHILE"/><option><nonterminal name="S"/></option><nonterminal name="condition"/><literal tmark="-" string="DO"/><option><nonterminal name="S"/></option><nonterminal name="do-statements"/><literal tmark="-" string="END"/><option><nonterminal name="S"/></option></alt></rule><rule name="do-statements"><alt><nonterminal mark="-" name="StatementSequence"/></alt></rule><rule name="statement"><comment/><alt/><alt><nonterminal name="assignment"/></alt><alt><nonterminal name="ProcedureCall"/></alt><alt><nonterminal name="IfStatement"/></alt><alt><nonterminal name="WhileStatement"/></alt></rule><rule name="StatementSequence"><alt><repeat1><nonterminal name="statement"/><sep><alts><alt><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></sep></repeat1></alt></rule><comment> Wirth's formulation is closer to the following, but that complicates whitespace
   handling. 

         statement = (assignment; ProcedureCall; IfStatement; WhileStatement)?.
 StatementSequence = statement++SEMI.
 </comment><rule name="IdentList"><alt><repeat1><nonterminal name="ident"/><sep><alts><alt><literal tmark="-" string=","/><option><nonterminal name="S"/></option></alt></alts></sep></repeat1></alt></rule><rule name="ArrayType"><alt><literal tmark="-" string="ARRAY"/><option><nonterminal name="S"/></option><nonterminal name="expression"/><literal tmark="-" string="OF"/><option><nonterminal name="S"/></option><nonterminal name="type"/></alt></rule><rule name="FieldList"><alt><option><alts><alt><nonterminal name="IdentList"/><literal tmark="-" string=":"/><option><nonterminal name="S"/></option><nonterminal name="type"/></alt></alts></option></alt></rule><rule name="RecordType"><alt><literal tmark="-" string="RECORD"/><option><nonterminal name="S"/></option><repeat1><nonterminal name="FieldList"/><sep><alts><alt><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></sep></repeat1><literal tmark="-" string="END"/><option><nonterminal name="S"/></option></alt></rule><rule name="type"><alt><nonterminal name="ident"/></alt><alt><nonterminal name="ArrayType"/></alt><alt><nonterminal name="RecordType"/></alt></rule><rule name="FPSection"><alt><option><alts><alt><literal tmark="-" string="VAR"/><nonterminal name="S"/></alt></alts></option><nonterminal name="IdentList"/><literal tmark="-" string=":"/><option><nonterminal name="S"/></option><nonterminal name="type"/></alt></rule><rule name="FormalParameters"><alt><literal tmark="-" string="("/><option><nonterminal name="S"/></option><repeat0><nonterminal name="FPSection"/><sep><alts><alt><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></sep></repeat0><literal tmark="-" string=")"/><option><nonterminal name="S"/></option></alt></rule><rule name="ProcedureHeading"><alt><literal tmark="-" string="PROCEDURE"/><nonterminal name="S"/><nonterminal name="ident"/><option><nonterminal name="FormalParameters"/></option></alt></rule><rule name="ProcedureBody"><alt><nonterminal name="declarations"/><option><alts><alt><literal tmark="-" string="BEGIN"/><option><nonterminal name="S"/></option><nonterminal name="StatementSequence"/></alt></alts></option><literal tmark="-" string="END"/><nonterminal name="S"/><nonterminal mark="@" name="ident"/></alt></rule><rule name="ProcedureDeclaration"><alt><nonterminal name="ProcedureHeading"/><literal tmark="-" string=";"/><option><nonterminal name="S"/></option><nonterminal name="ProcedureBody"/></alt></rule><rule name="declarations"><alt><option><nonterminal name="constants"/></option><option><nonterminal name="types"/></option><option><nonterminal name="variables"/></option><option><nonterminal name="procedures"/></option></alt></rule><rule name="constants"><alt><literal tmark="-" string="CONST"/><nonterminal name="S"/><repeat0><alts><alt><nonterminal name="ident"/><literal tmark="-" string="="/><option><nonterminal name="S"/></option><nonterminal name="expression"/><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></repeat0></alt></rule><rule name="types"><alt><literal tmark="-" string="TYPE"/><nonterminal name="S"/><repeat0><alts><alt><nonterminal name="IdentList"/><literal tmark="-" string="="/><option><nonterminal name="S"/></option><nonterminal name="type"/><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></repeat0></alt></rule><rule name="variables"><alt><literal tmark="-" string="VAR"/><nonterminal name="S"/><repeat0><alts><alt><nonterminal name="IdentList"/><literal tmark="-" string=":"/><option><nonterminal name="S"/></option><nonterminal name="type"/><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></repeat0></alt></rule><rule name="procedures"><alt><repeat1><alts><alt><nonterminal name="ProcedureDeclaration"/><literal tmark="-" string=";"/><option><nonterminal name="S"/></option></alt></alts></repeat1></alt></rule><comment> S and comment added here to make the grammar usable without
  a scanner. N.B. Comments nest. </comment><rule mark="-" name="S"><alt><repeat1><alts><alt><nonterminal name="ws"/></alt><alt><nonterminal name="comment"/></alt></alts></repeat1></alt></rule><rule mark="-" name="ws"><alt><inclusion tmark="-"><member string=" "/><member hex="09"/><member hex="0A"/><member hex="0D"/></inclusion></alt></rule><rule name="comment"><alt><literal tmark="-" string="(*"/><nonterminal name="comment-body"/><literal tmark="-" string="*)"/></alt></rule><rule name="comment-body"><alt><nonterminal name="comment-chars"/><option><alts><alt><alts><alt><repeat1><nonterminal name="comment"/><sep><nonterminal name="comment-chars"/></sep></repeat1></alt></alts><option><nonterminal name="comment-chars"/></option></alt></alts></option></alt></rule><rule mark="-" name="comment-chars"><alt><repeat1><alts><alt><nonterminal name="cc1"/></alt><alt><nonterminal name="cc2"/></alt><alt><nonterminal name="cc3"/></alt></alts></repeat1><repeat0><nonterminal name="star"/></repeat0><repeat0><nonterminal name="lpar"/></repeat0></alt><alt><repeat1><nonterminal name="star"/></repeat1><repeat0><nonterminal name="lpar"/></repeat0></alt><alt><repeat1><nonterminal name="lpar"/></repeat1></alt></rule><rule mark="-" name="cc1"><alt><nonterminal name="not-star-or-lpar"/></alt></rule><rule mark="-" name="cc2"><alt><repeat1><nonterminal name="lpar"/></repeat1><nonterminal name="not-star-or-lpar"/></alt></rule><rule mark="-" name="cc3"><alt><repeat1><nonterminal name="star"/></repeat1><repeat1><nonterminal name="lpar"/></repeat1><nonterminal name="not-star-or-lpar"/></alt><alt><repeat1><nonterminal name="star"/></repeat1><nonterminal name="not-star-or-lrpar"/></alt></rule><rule mark="-" name="not-star-or-lpar"><alt><exclusion><member string="*("/></exclusion></alt></rule><rule mark="-" name="not-star-or-lrpar"><alt><exclusion><member string="(*)"/></exclusion></alt></rule><rule mark="-" name="lpar"><alt><literal string="("/></alt></rule><rule mark="-" name="star"><alt><literal string="*"/></alt></rule><rule mark="-" name="digit"><alt><inclusion><member from="0" to="9"/></inclusion></alt></rule><rule mark="-" name="letter"><alt><inclusion><member from="a" to="z"/><member from="A" to="Z"/></inclusion></alt></rule><rule name="TIMES"><alt><literal tmark="-" string="*"/><option><nonterminal name="S"/></option></alt></rule><rule name="DIV"><alt><literal tmark="-" string="DIV"/><option><nonterminal name="S"/></option></alt></rule><rule name="MOD"><alt><literal tmark="-" string="MOD"/><option><nonterminal name="S"/></option></alt></rule><rule name="AND"><alt><literal tmark="-" string="AND"/><option><nonterminal name="S"/></option></alt></rule><rule name="PLUS"><alt><literal tmark="-" string="+"/><option><nonterminal name="S"/></option></alt></rule><rule name="MINUS"><alt><literal tmark="-" string="-"/><option><nonterminal name="S"/></option></alt></rule><rule name="OR"><alt><literal tmark="-" string="OR"/><option><nonterminal name="S"/></option></alt></rule><rule name="EQL"><alt><literal tmark="-" string="="/><option><nonterminal name="S"/></option></alt></rule><rule name="NEQ"><alt><literal tmark="-" string="#"/><option><nonterminal name="S"/></option></alt></rule><rule name="LSS"><alt><literal tmark="-" string="&lt;"/><option><nonterminal name="S"/></option></alt></rule><rule name="LEQ"><alt><literal tmark="-" string="&lt;="/><option><nonterminal name="S"/></option></alt></rule><rule name="GTR"><alt><literal tmark="-" string=">"/><option><nonterminal name="S"/></option></alt></rule><rule name="GEQ"><alt><literal tmark="-" string=">="/><option><nonterminal name="S"/></option></alt></rule><comment> Separators </comment></ixml>
