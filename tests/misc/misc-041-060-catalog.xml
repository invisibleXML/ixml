<tc:test-catalog xmlns:tc="https://github.com/invisibleXML/ixml/test-catalog"
		 xmlns:ixml="http://invisiblexml.org/NS"
		 xmlns:ap="http://blackmesatech.com/2019/iXML/Aparecium"		 
		 name="Misc tests 3"
		 release-date="2022-06-28"
		 >
  <tc:description>
    <tc:p>Grammars 41-60.</tc:p>
    <tc:p>Tests compiled manually in 2018 and 2019, re-packaged and
    extended (supplying test cases where needed) in 2022.</tc:p>
  </tc:description>
  
  <tc:description>
    <tc:p>Note that some tests have alternate results for processors
    operating in non-standard modes, in particular modes in which
    they tolerate multiple definitions and undefined nonterminals
    or in which they do not tolerate non-productive nonterminals
    or unreachable nonterminals.</tc:p>
    <tc:p>For a description of the form in which alternate results
    are recorded, see tests/misc-grammar/test-catalog.xml.</tc:p>
  </tc:description>
  
  <tc:test-set name="sample.grammar.41">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>
	Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
	Compilerbaus (Bonn: Addison-Wesley, 1996), pp. 36-37.
      </tc:p>
      <tc:p>
	Grammar for Oberon-0, the subset of Oberon for which the book
	describes a compiler.
      </tc:p>
      <tc:p>	
	Rules for whitespace and comments added for usability; Wirth
	assumes a lexer to eat whitespace.  This grammar experiments
	with a pattern in which nonterminals normally begin and end
	with non-whitespace characters, so in the XML any whitespace
	goes outside the tags, not inside.  (A different style is
	shown in sample.grammar.41bis.)
      </tc:p>
      <tc:p>
	(For what it's worth: in some ways the raw parse tree produced
	by this grammar is nicer than the raw parse tree produced by
	grammar 41bis, but optional nonterminals and nonterminals
	which can produce the empty string cause ambiguity unless they
	are handled specially.)
      </tc:p>
    </tc:description>
    
    <tc:ixml-grammar-ref href="grammars/sample.grammar.41.ixml"/>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/sample.grammar.41.xml"/>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g41.c00">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Sample Oberon-0 module from the same source as the
	grammar, pp. 37-38.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.oberon-0"/>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/Samples.oberon-0.g41.xml"/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c01">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by deleting the number 2.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon01.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c02">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c01.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by replacing the number 2 with an instance of the
	nonterminal 'types' (part of 'declarations').</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon02.oberon-0"/>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c03">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c01.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by inserting after the number 2 an instance of the
	nonterminal 'ProcedureHeading'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon03.oberon-0"/>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c04">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Variant generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by deleting the expresssion 'y'.</tc:p>
	<tc:p>This was intended as an error case, but it
	produces a legitimate Oberon program:  the actual parameters
	list in a function call may be empty.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon04.oberon-0"/>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/Samples.bogon04.oberon-0.xml"/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c05">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by replacing the expresssion 'y' with an
	instance of nonterminal NEQ.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon05.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c06">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by inserting an instance of 'RecordType' before the
	expresssion 'y'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon06.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c07">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by deleting the identifier 'k'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon07.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c08">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by changing the identifier 'k' to a subscript
	(so it became x &lt; a[[k]]).</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon08.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41.c09">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by inserting a selector before the identifier 'k',
	so the text becomes x &lt; a[.field k]).</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon09.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.41bis">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>
	Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
	Compilerbaus (Bonn: Addison-Wesley, 1996), pp. 36-37.
      </tc:p>
      <tc:p>	
	Same grammar as sample.grammar.41 except for whitespace
	handling.  This grammar experiments with a pattern in which
	every low-level token ends with optional whitespace; it's the
	same pattern shown in the ixml specification grammar.  (A
	different style is shown in sample.grammar.41bis.)
      </tc:p>
      <tc:p>
	(For what it's worth: in some ways the raw parse tree produced
	by this grammar feels off -- trailing whitespace is NOT part
	of an identifier or number!  But this approach can be done
	more or less mechanically and does not have trouble with
	optional nonterminals or nonterminals which can produce the
	empty string.  So unless whitespace must be exposed in the
	result, this approach to whitespace appears preferable.)
      </tc:p>
    </tc:description>
    
    <tc:ixml-grammar-ref href="grammars/sample.grammar.41bis.ixml"/>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/sample.grammar.41bis.xml"/>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g41bis.c00">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Sample Oberon-0 module from the same source as the
	grammar, pp. 37-38.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.oberon-0"/>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/Samples.oberon-0.g41bis.xml"/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c01">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by deleting the number 2.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon01.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c02">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c01.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by replacing the number 2 with an instance of the
	nonterminal 'types' (part of 'declarations').</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon02.oberon-0"/>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c03">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c01.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by inserting after the number 2 an instance of the
	nonterminal 'ProcedureHeading'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon03.oberon-0"/>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c04">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Variant generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by deleting the expresssion 'y'.</tc:p>
	<tc:p>This was intended as an error case, but it
	produces a legitimate Oberon program:  the actual parameters
	list in a function call may be empty.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon04.oberon-0"/>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/Samples.bogon04.oberon-0.xml"/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c05">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by replacing the expresssion 'y' with an
	instance of nonterminal NEQ.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon05.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c06">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by inserting an instance of 'RecordType' before the
	expresssion 'y'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon06.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c07">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by deleting the identifier 'k'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon07.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c08">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by changing the identifier 'k' to a subscript
	(so it became x &lt; a[[k]]).</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon08.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41bis.c09">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by inserting a selector before the identifier 'k',
	so the text becomes x &lt; a[.field k]).</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon09.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.41ter">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>
	Sample grammar derived from one in Niklaus Wirth, Grundlagen
	und Techniken des Compilerbaus (Bonn: Addison-Wesley, 1996),
	pp. 36-37.
      </tc:p>
      <tc:p>
	Derived from sample.grammar.41bis by rewriting the expression
	syntax so that nonterminals are visible in the XML only when
	needed to group multiple children and invisible if they have
	only one child.
      </tc:p>
    </tc:description>
    
    <tc:ixml-grammar-ref href="grammars/sample.grammar.41ter.ixml"/>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/sample.grammar.41ter.xml"/>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g41ter.c00">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Sample Oberon-0 module from the same source as the
	grammar, pp. 37-38.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.oberon-0"/>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/Samples.oberon-0.g41ter.xml"/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c01">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by deleting the number 2.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon01.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c02">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c01.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by replacing the number 2 with an instance of the
	nonterminal 'types' (part of 'declarations').</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon02.oberon-0"/>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c03">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c01.</tc:p>
	<tc:p>In the Divide routine, the assignment w := 2 * w was
	modified by inserting after the number 2 an instance of the
	nonterminal 'ProcedureHeading'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon03.oberon-0"/>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c04">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Variant case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by deleting the expresssion 'y'.  This was supposed
	to be an error, but it's not.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon04.oberon-0"/>
      <tc:result>
	<tc:assert-xml-ref href="parse-trees/Samples.bogon04.oberon-0.41ter.xml"/>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c05">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by replacing the expresssion 'y' with an
	instance of nonterminal NEQ.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon05.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c06">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the Divide routine, the procedure call Write(y) was
	modified by inserting an instance of 'RecordType' before the
	expresssion 'y'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon06.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c07">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by deleting the identifier 'k'.</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon07.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c08">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by changing the identifier 'k' to a subscript
	(so it became x &lt; a[[k]]).</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon08.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    
    <tc:test-case name="g41ter.c09">
      <tc:created by="cmsmcq" on="2022-06-15"/>
      <tc:description>
	<tc:p>Error case generated by random modification of g41.c00.</tc:p>
	<tc:p>In the BinSearch routine, the test x &lt; a[k] was
	modified by inserting a selector before the identifier 'k',
	so the text becomes x &lt; a[.field k]).</tc:p>
      </tc:description>
      <tc:test-string-ref href="inputs/Samples.bogon09.oberon-0"/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.42">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>
	Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
	Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
	Second edition New York:  Springer, 2008), pp. 32 (1e) and 23 (2e).
      </tc:p>
      <tc:p>
	Rules for ws added for convenience; Grune and Jacobs assume the lexer
	eats whitespace.
      </tc:p>
    </tc:description>
    
    <tc:ixml-grammar>
      Sentence: Name; List, S, "and", S, Name.
      Name: "tom"; "dick"; "harry".
      List: Name, ",", S, List; Name.

      S: " "+.

      { Generates

      tom
      dick
      tom and dick
      tom, dick and harry
      tom, tom, harry and dick

      Does not accept

      tom, dick, harry
      tom and dick and harry
    }</tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
      <ixml
        ><rule name="Sentence"
          ><alt
            ><nonterminal name="Name"
          /></alt
          ><alt
            ><nonterminal name="List"
            /><nonterminal name="S"
            /><literal string="and"
            /><nonterminal name="S"
            /><nonterminal name="Name"
          /></alt
        ></rule
        ><rule name="Name"
          ><alt
            ><literal string="tom"
          /></alt
          ><alt
            ><literal string="dick"
          /></alt
          ><alt
            ><literal string="harry"
          /></alt
        ></rule
        ><rule name="List"
          ><alt
            ><nonterminal name="Name"
            /><literal string=","
            /><nonterminal name="S"
            /><nonterminal name="List"
          /></alt
          ><alt
            ><nonterminal name="Name"
          /></alt
        ></rule
        ><rule name="S"
          ><alt
            ><repeat1
              ><literal string=" "
            /></repeat1
          ></alt
        ></rule
        ><comment> Generates

      tom
      dick
      tom and dick
      tom, dick and harry
      tom, tom, harry and dick

      Does not accept

      tom, dick, harry
      tom and dick and harry
    </comment
      ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g42.c01">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence><Name>tom</Name></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c02">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>dick</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence><Name>dick</Name></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c03">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom and dick</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence><List><Name>tom</Name></List><S> </S>and<S> </S><Name>dick</Name></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c04">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, dick and harry</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence><List><Name>tom</Name>,<S> </S
            ><List><Name>dick</Name></List></List
            ><S> </S>and<S> </S><Name>harry</Name></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c05">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, tom, harry and dick</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence><List><Name>tom</Name>,<S> </S
            ><List><Name>tom</Name>,<S> </S
            ><List><Name>harry</Name></List></List></List
            ><S> </S>and<S> </S><Name>dick</Name></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c06">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, dick, harry</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c07">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom and dick and harry</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c08">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, dick, and harry</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c09">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>Tinkers to Evers to Chance</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c10">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c11">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, dick,</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c12">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, dick, harry</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c13">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>harry and</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c14">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom, dick and, harry</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g42.c15">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>tom and dick,</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.43">
    <tc:description>
      <tc:p>Another grammar from Grune and Jacobs, describing possible
      elevator motion (in a building with infinitely many floors above
      and below) from departure from a floor until return to that
      floor.</tc:p>
    </tc:description>
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 33 (1e) and 26 (2e).

    Rules for ws added for convenience; Grune and Jacobs assume the lexer
    eats whitespace. Peculiarity:  whitespace is allowed but not required,
    and it is allowed after any keyword but not at the beginning of the input.

    }
    { Revisions:
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }

    ZeroMotion: "up", S, ZeroMotion, "down", S, ZeroMotion;
    "down", S, ZeroMotion, "up", S, ZeroMotion;
    { nil }.

    -S: -[" "; #09; #A; #D]*.</tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>	    
	    <ixml
              ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 33 (1e) and 26 (2e).

    Rules for ws added for convenience; Grune and Jacobs assume the lexer
    eats whitespace. Peculiarity:  whitespace is allowed but not required,
    and it is allowed after any keyword but not at the beginning of the input.

    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
              ><rule name="ZeroMotion"
                ><alt
		  ><literal string="up"
		  /><nonterminal name="S"
		  /><nonterminal name="ZeroMotion"
		  /><literal string="down"
		  /><nonterminal name="S"
		  /><nonterminal name="ZeroMotion"
		/></alt
		><alt
		  ><literal string="down"
		  /><nonterminal name="S"
		  /><nonterminal name="ZeroMotion"
		  /><literal string="up"
		  /><nonterminal name="S"
		  /><nonterminal name="ZeroMotion"
		/></alt
		><comment> nil </comment
		><alt
              /></rule
              ><rule mark="-" name="S"
		><alt
		  ><repeat0
		    ><inclusion tmark="-"
                      ><member string=" "
                      /><member hex="09"
                      /><member hex="A"
                      /><member hex="D"
		    /></inclusion
		  ></repeat0
		></alt
              ></rule
	    ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g43.c01">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string></tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <ZeroMotion/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c02">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>up down</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <ZeroMotion>up<ZeroMotion/>down<ZeroMotion/></ZeroMotion>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c03">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>down up</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <ZeroMotion>down<ZeroMotion/>up<ZeroMotion/></ZeroMotion>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c04">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>down up up down</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <ZeroMotion
            >down<ZeroMotion/>up<ZeroMotion
              >up<ZeroMotion/>down<ZeroMotion
            /></ZeroMotion></ZeroMotion>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c05">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>down up down up</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <ZeroMotion ixml:state="ambiguous"
            >down<ZeroMotion/>up<ZeroMotion
              >down<ZeroMotion/>up<ZeroMotion
            /></ZeroMotion></ZeroMotion>
	</tc:assert-xml>
	<tc:assert-xml>
	  <ZeroMotion ixml:state="ambiguous"
            >down<ZeroMotion
              >up<ZeroMotion/>down<ZeroMotion
              /></ZeroMotion
            >up<ZeroMotion
          /></ZeroMotion>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c06">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>up up up down up down down down</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <ZeroMotion ixml:state="ambiguous"
              >up<ZeroMotion
                  >up<ZeroMotion
                      >up<ZeroMotion
                          >down<ZeroMotion/>up<ZeroMotion
                      /></ZeroMotion
                  >down<ZeroMotion/></ZeroMotion
              >down<ZeroMotion/></ZeroMotion
          >down<ZeroMotion/></ZeroMotion>
	</tc:assert-xml>
	<tc:assert-xml>
	  <ZeroMotion ixml:state="ambiguous"
              >up<ZeroMotion
                  >up<ZeroMotion
                      >up<ZeroMotion/>down<ZeroMotion
                          >up<ZeroMotion/>down<ZeroMotion
                      /></ZeroMotion
                  ></ZeroMotion
                  >down<ZeroMotion/></ZeroMotion
              >down<ZeroMotion
          /></ZeroMotion>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c07">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>up</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c08">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>down</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c09">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>up up up down</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c10">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>down down up down</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c11">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>down up down down</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g43.c12">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>up up up up</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.44">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A simple toy grammar for a small set of English
      sentences.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 34 (1e) and 26 (2e).

    Rules for ws added for convenience; Grune and Jacobs assume the lexer
    eats whitespace. Peculiarity:  whitespace is allowed but not required,
    and it is allowed after any word but not at the beginning of the input. 
    }

    { Revisions:
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }

    Sentence: Subject, Verb, Object.
    Subject: NounPhrase.
    Object: NounPhrase.
    NounPhrase: "the", S, QualifiedNoun.
    QualifiedNoun: Noun; Adjective, QualifiedNoun.
    Noun:  noun, S.
    Adjective: adjective, S.
    Verb: verb, S.
    noun: "castle"; "caterpillar"; "cats".
    adjective: "well-read"; "white"; "wistful".
    verb: "admires"; "bark"; "criticize".

    -S: -[" "; #09; #A; #D]*.

    { Produces, inter alia:

    the well-read cats criticize the wistful caterpillar
    the cats admires the white well-read castle

    }</tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 34 (1e) and 26 (2e).

    Rules for ws added for convenience; Grune and Jacobs assume the lexer
    eats whitespace. Peculiarity:  whitespace is allowed but not required,
    and it is allowed after any word but not at the beginning of the input. 
    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
            ><rule name="Sentence"
              ><alt
		><nonterminal name="Subject"
		/><nonterminal name="Verb"
		/><nonterminal name="Object"
              /></alt
            ></rule
            ><rule name="Subject"
              ><alt
		><nonterminal name="NounPhrase"
              /></alt
            ></rule
            ><rule name="Object"
              ><alt
		><nonterminal name="NounPhrase"
              /></alt
            ></rule
            ><rule name="NounPhrase"
              ><alt
		><literal string="the"
		/><nonterminal name="S"
		/><nonterminal name="QualifiedNoun"
              /></alt
            ></rule
            ><rule name="QualifiedNoun"
              ><alt
		><nonterminal name="Noun"
              /></alt
              ><alt
		><nonterminal name="Adjective"
		/><nonterminal name="QualifiedNoun"
              /></alt
            ></rule
            ><rule name="Noun"
              ><alt
		><nonterminal name="noun"
		/><nonterminal name="S"
              /></alt
            ></rule
            ><rule name="Adjective"
              ><alt
		><nonterminal name="adjective"
		/><nonterminal name="S"
              /></alt
            ></rule
            ><rule name="Verb"
              ><alt
		><nonterminal name="verb"
		/><nonterminal name="S"
              /></alt
            ></rule
            ><rule name="noun"
              ><alt
		><literal string="castle"
              /></alt
              ><alt
		><literal string="caterpillar"
              /></alt
              ><alt
		><literal string="cats"
              /></alt
            ></rule
            ><rule name="adjective"
              ><alt
		><literal string="well-read"
              /></alt
              ><alt
		><literal string="white"
              /></alt
              ><alt
		><literal string="wistful"
              /></alt
            ></rule
            ><rule name="verb"
              ><alt
		><literal string="admires"
              /></alt
              ><alt
		><literal string="bark"
              /></alt
              ><alt
		><literal string="criticize"
              /></alt
            ></rule
            ><rule mark="-" name="S"
              ><alt
		><repeat0
		  ><inclusion tmark="-"
                    ><member string=" "
                    /><member hex="09"
                    /><member hex="A"
                    /><member hex="D"
		  /></inclusion
		></repeat0
              ></alt
            ></rule
            ><comment> Produces, inter alia:

    the well-read cats criticize the wistful caterpillar
    the cats admires the white well-read castle

    </comment></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g44.c01">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>the well-read cats criticize the wistful caterpillar</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence
	    ><Subject
	      ><NounPhrase>the<QualifiedNoun
              ><Adjective
		><adjective>well-read</adjective
              ></Adjective
              ><QualifiedNoun
		><Noun
		  ><noun>cats</noun
		></Noun
              ></QualifiedNoun></QualifiedNoun
	      ></NounPhrase
	    ></Subject
	    ><Verb
	      ><verb>criticize</verb
	    ></Verb
	    ><Object
	      ><NounPhrase>the<QualifiedNoun
              ><Adjective
		><adjective>wistful</adjective
              ></Adjective
              ><QualifiedNoun
		><Noun
		  ><noun>caterpillar</noun
		></Noun
              ></QualifiedNoun></QualifiedNoun
	      ></NounPhrase
	    ></Object
	  ></Sentence>	  
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g44.c02">
      <tc:created on="2022-06-16" by="cmsmcq"/>
      <tc:test-string>the cats admires the well-read white castle</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence
	    ><Subject
	      ><NounPhrase>the<QualifiedNoun
              ><Noun
		><noun>cats</noun
              ></Noun></QualifiedNoun
	      ></NounPhrase
	    ></Subject
	    ><Verb
	      ><verb>admires</verb
	    ></Verb
	    ><Object
	      ><NounPhrase>the<QualifiedNoun
              ><Adjective
		><adjective>well-read</adjective
		></Adjective
              ><QualifiedNoun
		><Adjective
		  ><adjective>white</adjective
              ></Adjective
		><QualifiedNoun
		  ><Noun
		    ><noun>castle</noun
		  ></Noun
		></QualifiedNoun
              ></QualifiedNoun></QualifiedNoun
	      ></NounPhrase
	    ></Object
	  ></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g44.c03">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>the cats admires the white well-read castle</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence
	    ><Subject
	      ><NounPhrase>the<QualifiedNoun
              ><Noun
		><noun>cats</noun
              ></Noun></QualifiedNoun
	      ></NounPhrase
	    ></Subject
	    ><Verb
	      ><verb>admires</verb
	    ></Verb
	    ><Object
	      ><NounPhrase>the<QualifiedNoun
              ><Adjective
		><adjective>white</adjective
              ></Adjective
              ><QualifiedNoun
		><Adjective
		  ><adjective>well-read</adjective
		></Adjective
		><QualifiedNoun
		  ><Noun
		    ><noun>castle</noun
		  ></Noun
		></QualifiedNoun
              ></QualifiedNoun></QualifiedNoun
	      ></NounPhrase
	    ></Object
	  ></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g44.c04">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>the cats bark</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g44.c05">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>the castle admires cats</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g44.c06">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>the castle admires the cats</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sentence
	    ><Subject
	      ><NounPhrase>the<QualifiedNoun
              ><Noun
		><noun>castle</noun
              ></Noun></QualifiedNoun
	      ></NounPhrase
	    ></Subject
	    ><Verb
	      ><verb>admires</verb
	    ></Verb
	    ><Object
	      ><NounPhrase>the<QualifiedNoun
              ><Noun
		><noun>cats</noun
	      ></Noun></QualifiedNoun
	      ></NounPhrase
	    ></Object
          ></Sentence>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.45">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A much simpler grammar for the 'tom, dick, and harry'
      example of sample grammar 42.</tc:p>
      <tc:p>
      </tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 44 (1e) and 33 (2e).

    }

    { Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }

    Sentence: (( ["t"; "d"; "h"], ",")*, ["t"; "d"; "h"], "&amp;")?, ["t"; "d"; "h"].
    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 44 (1e) and 33 (2e).

    </comment
             ><comment> Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
             ><rule name="Sentence"
               ><alt
		 ><option
		   ><alts
                     ><alt
                       ><repeat0
			 ><alts
			   ><alt
                             ><inclusion
                               ><member string="t"
                               /><member string="d"
                               /><member string="h"
                             /></inclusion
                             ><literal string=","
			   /></alt
			 ></alts
                       ></repeat0
                       ><inclusion
			 ><member string="t"
			 /><member string="d"
			 /><member string="h"
                       /></inclusion
                       ><literal string="&amp;"
                     /></alt
		   ></alts
		 ></option
		 ><inclusion
		   ><member string="t"
		   /><member string="d"
		   /><member string="h"
		 /></inclusion
               ></alt
             ></rule
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g45.c01">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c02">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>tdh</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c03">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>t</tc:test-string>
      <tc:result><tc:assert-xml>
	<Sentence>t</Sentence>
      </tc:assert-xml></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c04">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h</tc:test-string>
      <tc:result><tc:assert-xml>
	<Sentence>h</Sentence>
      </tc:assert-xml></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c05">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>d&amp;h</tc:test-string>
      <tc:result><tc:assert-xml>
	<Sentence>d&amp;h</Sentence>
      </tc:assert-xml></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c06">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h,t&amp;d</tc:test-string>
      <tc:result><tc:assert-xml>
	<Sentence>h,t&amp;d</Sentence>
      </tc:assert-xml></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c07">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h,t,t,t,t&amp;d</tc:test-string>
      <tc:result><tc:assert-xml>
	<Sentence>h,t,t,t,t&amp;d</Sentence>
      </tc:assert-xml></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c08">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>t,d,h</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c09">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h&amp;t&amp;d</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c10">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h,t,&amp;d</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c11">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h,t,</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c12">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>h,t,d</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c13">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>t&amp;</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c14">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>t,t&amp;,h</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g45.c15">
      <tc:created on="2022-06-17" by="cmsmcq"/>
      <tc:test-string>t&amp;t,h</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.46">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A grammar with a non-productive nonterminal.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 57 (1e) and 48 (2e).

    This is adapted / extended from the example in G and J's discussion of
    non-productive non-terminals.

    }

    { Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }


    S: "b"; X.
    X: "a", X.

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 57 (1e) and 48 (2e).

    This is adapted / extended from the example in G and J's discussion of
    non-productive non-terminals.

    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
            ><rule name="S"
              ><alt
		><literal string="b"
              /></alt
              ><alt
		><nonterminal name="X"
              /></alt
            ></rule
            ><rule name="X"
              ><alt
		><literal string="a"
		/><nonterminal name="X"
              /></alt
            ></rule
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
      <tc:description>
	<tc:p>If the processor has been asked to reject grammars
	with unproductive symbols, this grammar should be rejected.</tc:p>
      </tc:description>
      <tc:app-info>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:grammar-test>
    <tc:test-case name="g46.c01">
      <tc:test-string>b</tc:test-string>
      <tc:result>
	<tc:assert-xml> <S>b</S> </tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g46.c02">
      <tc:test-string>a</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g46.c03">
      <tc:test-string>ba</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g46.c04">
      <tc:test-string>baaaaaaaa</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.47">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A simple example of ambiguity.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 63 (1e) and 63 (2e).

    Caption is: "A simple ambiguous grammar."

    }

    { Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }

    Sum: Digit;
         Sum, "+", Sum.
    Digit:  ["0"-"9"].

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
          <ixml
            ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 63 (1e) and 63 (2e).

    Caption is: "A simple ambiguous grammar."

    </comment
            ><comment> Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
            ><rule name="Sum"
              ><alt
                ><nonterminal name="Digit"
              /></alt
              ><alt
                ><nonterminal name="Sum"
                /><literal string="+"
                /><nonterminal name="Sum"
              /></alt
            ></rule
            ><rule name="Digit"
              ><alt
                ><inclusion
                  ><member from="0" to="9"
                /></inclusion
              ></alt
            ></rule
          ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g47.c01">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c02">
      <tc:test-string>7</tc:test-string>
      <tc:result>
	<tc:assert-xml><Sum><Digit>7</Digit></Sum></tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c03">
      <tc:test-string>7+4</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sum><Sum><Digit>7</Digit></Sum>+<Sum><Digit>4</Digit></Sum></Sum>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c04">
      <tc:test-string>9+7+4</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sum ixml:state="ambiguous"
	       ><Sum><Sum><Digit>9</Digit></Sum>+<Sum><Digit>7</Digit></Sum></Sum
	       >+<Sum><Digit>4</Digit></Sum
	  ></Sum>
	</tc:assert-xml>
	<tc:assert-xml>
	  <Sum ixml:state="ambiguous"
	    ><Sum><Digit>9</Digit></Sum
            >+<Sum><Sum><Digit>7</Digit></Sum>+<Sum><Digit>4</Digit></Sum></Sum
	  ></Sum>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c05">
      <tc:test-string>1+9+7+4</tc:test-string>
      <tc:result>
	<tc:assert-xml><!-- ((1+9)+(7+4)) -->
	  <Sum ixml:state="ambiguous"
	    ><Sum><Sum><Digit>1</Digit></Sum
	    >+<Sum><Digit>9</Digit></Sum></Sum
            >+<Sum><Sum><Digit>7</Digit></Sum
	    >+<Sum><Digit>4</Digit></Sum></Sum
	  ></Sum>
	</tc:assert-xml>
	<tc:assert-xml><!-- (((1+9)+7)+4) -->
	  <Sum ixml:state="ambiguous"
	    ><Sum
              ><Sum
                ><Sum><Digit>1</Digit></Sum
	        >+<Sum><Digit>9</Digit></Sum></Sum
              >+<Sum><Digit>7</Digit></Sum></Sum
	    >+<Sum><Digit>4</Digit></Sum
	  ></Sum>
	</tc:assert-xml>
	<tc:assert-xml><!-- (1+(9+(7+4))) -->
	  <Sum ixml:state="ambiguous"
	    ><Sum><Digit>1</Digit></Sum
	    >+<Sum><Sum><Digit>9</Digit></Sum
	    >+<Sum><Sum><Digit>7</Digit></Sum
	    >+<Sum><Digit>4</Digit></Sum></Sum></Sum
	  ></Sum>
	</tc:assert-xml>
	<tc:assert-xml><!-- (1+((9+7)+4)) -->
	  <Sum ixml:state="ambiguous"
	    ><Sum><Digit>1</Digit></Sum
	    >+<Sum><Sum><Sum><Digit>9</Digit></Sum
	    >+<Sum><Digit>7</Digit></Sum></Sum
	    >+<Sum><Digit>4</Digit></Sum></Sum
	  ></Sum>
	</tc:assert-xml>
	<tc:assert-xml><!-- ((1+(9+7))+4) -->
	  <Sum ixml:state="ambiguous"
	    ><Sum
	      ><Sum><Digit>1</Digit></Sum
	      >+<Sum
		><Sum><Digit>9</Digit></Sum
                >+<Sum><Digit>7</Digit></Sum
	      ></Sum
	    ></Sum
            >+<Sum><Digit>4</Digit></Sum
	  ></Sum>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c06">
      <tc:test-string>9+</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c07">
      <tc:test-string>+5</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c08">
      <tc:test-string>1++2</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g47.c09">
      <tc:test-string>19+74</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.48">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>An unambiguous equivalent of sample.grammar.47.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 58 (1e) and 54 (2e).

    Caption is: "A grammar for sums of one-digit numbers."
    }

    { Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }

    Sum: Digit;
         Sum, "+", Digit.
    Digit:  ["0"-"9"].

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
          <ixml
            ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 58 (1e) and 54 (2e).

    Caption is: "A grammar for sums of one-digit numbers."
    </comment
            ><comment> Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
            ><rule name="Sum"
              ><alt
                ><nonterminal name="Digit"
              /></alt
              ><alt
                ><nonterminal name="Sum"
                /><literal string="+"
                /><nonterminal name="Digit"
              /></alt
            ></rule
            ><rule name="Digit"
              ><alt
                ><inclusion
                  ><member from="0" to="9"
                /></inclusion
              ></alt
            ></rule
          ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g48.c01">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c02">
      <tc:test-string>7</tc:test-string>
      <tc:result>
	<tc:assert-xml><Sum><Digit>7</Digit></Sum></tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c03">
      <tc:test-string>7+4</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sum><Sum><Digit>7</Digit></Sum>+<Digit>4</Digit></Sum>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c04">
      <tc:test-string>9+7+4</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Sum
	    ><Sum
	      ><Sum
		><Digit>9</Digit
	      ></Sum
              >+<Digit>7</Digit
            ></Sum
            >+<Digit>4</Digit
	  ></Sum>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c05">
      <tc:test-string>1+9+7+4</tc:test-string>
      <tc:result>
	<tc:assert-xml><!-- (((1+9)+7)+4) -->
	  <Sum
	    ><Sum
              ><Sum
                ><Sum><Digit>1</Digit></Sum
	        >+<Digit>9</Digit></Sum
              >+<Digit>7</Digit></Sum
	    >+<Digit>4</Digit
	  ></Sum>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c06">
      <tc:test-string>9+</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c07">
      <tc:test-string>+5</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c08">
      <tc:test-string>1++2</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g48.c09">
      <tc:test-string>19+74</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.49">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A very simple left-recursive grammar.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 83 (1e) and 105 (2e).

    They use this grammar to illustrate Unger parsing.
    }

    { Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    }

    Expr: Expr, "+", Term; Term.
    Term:  Term, "x" { or better yet [#00D7] = &#xD7; }, Factor; Factor.
    Factor: "(", Expr, ")"; "i".

    { e.g. "(i+i)xi" }

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    Second edition New York:  Springer, 2008), pp. 83 (1e) and 105 (2e).

    They use this grammar to illustrate Unger parsing.
    </comment
            ><comment> Revisions:
    2018-08-10 : CMSMcQ : add pointer to 2e
    2018-08-09 : CMSMcQ : made first transcription; needs checking.
    </comment
            ><rule name="Expr"
              ><alt
		><nonterminal name="Expr"
		/><literal string="+"
		/><nonterminal name="Term"
              /></alt
              ><alt
		><nonterminal name="Term"
              /></alt
            ></rule
            ><rule name="Term"
              ><alt
		><nonterminal name="Term"
		/><literal string="x"
		  ><comment> or better yet [#00D7] = &#xD7; </comment
		></literal
		><nonterminal name="Factor"
              /></alt
              ><alt
		><nonterminal name="Factor"
              /></alt
            ></rule
            ><rule name="Factor"
              ><alt
		><literal string="("
		/><nonterminal name="Expr"
		/><literal string=")"
              /></alt
              ><alt
		><literal string="i"
              /></alt
            ></rule
            ><comment> e.g. "(i+i)xi" </comment
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
      </tc:grammar-test>
    <tc:test-case name="g49.c01">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c02">
      <tc:test-string>i</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr><Term><Factor>i</Factor></Term></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c03">
      <tc:test-string>i+i</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr><Expr><Term><Factor>i</Factor></Term></Expr>+<Term><Factor>i</Factor></Term></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c04">
      <tc:test-string>ixi</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr><Term><Term><Factor>i</Factor></Term>x<Factor>i</Factor></Term></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c05">
      <tc:test-string>ixi+i</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr
	      ><Expr
		   ><Term><Term><Factor>i</Factor></Term>x<Factor>i</Factor></Term
	      ></Expr
	      >+<Term><Factor>i</Factor></Term></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c06">
      <tc:test-string>i+ixi</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr
            ><Expr
              ><Term
		><Factor>i</Factor
              ></Term
            ></Expr
	    >+<Term
              ><Term
		><Factor>i</Factor
	      ></Term
	      >x<Factor>i</Factor
            ></Term
	  ></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c07">
      <tc:test-string>(i+i)xi</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr
	    ><Term
	      ><Term
		><Factor
		  >(<Expr
		    ><Expr
		      ><Term
			><Factor>i</Factor
		      ></Term
		    ></Expr
		    >+<Term
		      ><Factor>i</Factor
		    ></Term
		  ></Expr
		  >)</Factor
	      ></Term
	      >x<Factor>i</Factor
	    ></Term
	  ></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c08">
      <tc:test-string>((i+((i))))xi</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Expr
	    ><Term
	      ><Term
		><Factor>(<Expr
		><Term
		  ><Factor>(<Expr
                  ><Expr
                    ><Term
                      ><Factor>i</Factor
                    ></Term
                    ></Expr>+<Term
                    ><Factor>(<Expr
                    ><Term
                      ><Factor>(<Expr
                      ><Term
                        ><Factor>i</Factor
                      ></Term
                      ></Expr>)</Factor
                    ></Term
                    ></Expr>)</Factor
                  ></Term
		  ></Expr>)</Factor
		></Term
		></Expr>)</Factor
		></Term>x<Factor>i</Factor
	    ></Term
	  ></Expr>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c09">
      <tc:test-string>((i+((i)))xi</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c10">
      <tc:test-string>(i+((i))))xi</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c11">
      <tc:test-string>ii+(i+i)</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c12">
      <tc:test-string>i++(i+i)</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c13">
      <tc:test-string>x+x+i</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g49.c14">
      <tc:test-string>i++</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.50">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>An awkward grammar for a simple language.</tc:p>
    </tc:description>
    <tc:ixml-grammar>
{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide
    (New York: Ellis Horwood, 1990), p. 86 (with typo),
    and second edition (New York:  Springer, 2008), p. 109
    (with typo corrected).

    They use this grammar to illustrate Unger parsing.
    "This grammar generates sequences of d's in an awkward way."
    }

    { Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    }

    S: L, S, D; .
    L: .
    D: "d".


    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide
    (New York: Ellis Horwood, 1990), p. 86 (with typo),
    and second edition (New York:  Springer, 2008), p. 109
    (with typo corrected).

    They use this grammar to illustrate Unger parsing.
    "This grammar generates sequences of d's in an awkward way."
    </comment
            ><comment> Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
		><nonterminal name="L"
		/><nonterminal name="S"
		/><nonterminal name="D"
              /></alt
              ><alt
            /></rule
            ><rule name="L"
              ><alt
            /></rule
            ><rule name="D"
              ><alt
		><literal string="d"
              /></alt
            ></rule
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g50.c01">
      <tc:test-string/>
      <tc:result>
	<tc:assert-xml>
	  <S/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g50.c02">
      <tc:test-string>D</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g50.c03">
      <tc:test-string>d</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S><L/><S/><D>d</D></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g50.c04">
      <tc:test-string>dd</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S><L/><S><L/><S/><D>d</D></S><D>d</D></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g50.c05">
      <tc:test-string>dddddddd</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S><L/><S><L/><S><L/><S><L/><S><L/><S><L
	  /><S><L/><S><L/><S/><D>d</D></S><D>d</D
	  ></S><D>d</D></S><D>d</D></S><D>d</D></S
	  ><D>d</D></S><D>d</D></S><D>d</D></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g50.c06">
      <tc:test-string>ddddddddx</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.51">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A grammar for numbers in scientific notation.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 89 (1e) and 112 (2e).

    They use this grammar to illustrate CYK parsing.
    "This grammar describes the syntax of numbers in scientific notation."

    Versions of this grammar after elimination of epsilon-rules, 
    after eliminating unit rules, and after further cleanup (elimination
    of unreachable non-terminals) are given in pp. 120-122 of 2e.  I
    have not made test cases from them.  A Chomsky Normal Form equivalent
    is sample grammar 54.
    }

    { Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    }

    Number: Integer; Real.
    Integer: Digit; Integer, Digit.
    Real: Integer, Fraction, Scale.
    Fraction:  ".", Integer.
    Scale:  "e", Sign, Integer; Empty.
    Digit:  ["0"-"9"].
    Sign:  "+"; "-".
    Empty: .

    {e.g. 32.5e+1 }

    { Hmm.  Required sign for scale? }


    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 89 (1e) and 112 (2e).

    They use this grammar to illustrate CYK parsing.
    "This grammar describes the syntax of numbers in scientific notation."

    Versions of this grammar after elimination of epsilon-rules, 
    after eliminating unit rules, and after further cleanup (elimination
    of unreachable non-terminals) are given in pp. 120-122 of 2e.  I
    have not made test cases from them.  A Chomsky Normal Form equivalent
    is sample grammar 54.
    </comment><comment> Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="Number"
              ><alt
		><nonterminal name="Integer"
              /></alt
              ><alt
		><nonterminal name="Real"
              /></alt
            ></rule
            ><rule name="Integer"
              ><alt
		><nonterminal name="Digit"
              /></alt
              ><alt
		><nonterminal name="Integer"
		/><nonterminal name="Digit"
              /></alt
            ></rule
            ><rule name="Real"
              ><alt
		><nonterminal name="Integer"
		/><nonterminal name="Fraction"
		/><nonterminal name="Scale"
              /></alt
            ></rule
            ><rule name="Fraction"
              ><alt
		><literal string="."
		/><nonterminal name="Integer"
              /></alt
            ></rule
            ><rule name="Scale"
              ><alt
		><literal string="e"
		/><nonterminal name="Sign"
		/><nonterminal name="Integer"
              /></alt
              ><alt
		><nonterminal name="Empty"
              /></alt
            ></rule
            ><rule name="Digit"
              ><alt
		><inclusion
		  ><member from="0" to="9"
		/></inclusion
              ></alt
            ></rule
            ><rule name="Sign"
              ><alt
		><literal string="+"
              /></alt
              ><alt
		><literal string="-"
              /></alt
            ></rule
            ><rule name="Empty"
              ><alt
            /></rule
            ><comment>e.g. 32.5e+1 </comment
            ><comment> Hmm.  Required sign for scale? </comment
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g51.c01">
      <tc:test-string>32.5e+1</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number><Real
	    ><Integer><Integer><Digit>3</Digit></Integer><Digit>2</Digit></Integer
	    ><Fraction>.<Integer><Digit>5</Digit></Integer></Fraction
	    ><Scale>e<Sign>+</Sign><Integer><Digit>1</Digit></Integer></Scale
	  ></Real></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c02">
      <tc:test-string>0</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number><Integer><Digit>0</Digit></Integer></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c03">
      <tc:test-string>21</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number><Integer><Integer><Digit>2</Digit></Integer
	  ><Digit>1</Digit></Integer></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c04">
      <tc:test-string>67.9</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number><Real
            ><Integer><Integer><Digit>6</Digit></Integer
            ><Digit>7</Digit></Integer
            ><Fraction>.<Integer><Digit>9</Digit
            ></Integer></Fraction
            ><Scale><Empty/></Scale
          ></Real></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c05">
      <tc:test-string>9978.8024</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Real
	      ><Integer
		><Integer
		  ><Integer
		    ><Integer
		      ><Digit>9</Digit
		    ></Integer
		    ><Digit>9</Digit
		  ></Integer
		  ><Digit>7</Digit
		></Integer
		><Digit>8</Digit
	      ></Integer
	      ><Fraction>.<Integer
              ><Integer
		><Integer
		  ><Integer
		    ><Digit>8</Digit
		  ></Integer
		  ><Digit>0</Digit
		></Integer
		><Digit>2</Digit
              ></Integer
              ><Digit>4</Digit
	    ></Integer
	      ></Fraction
	      ><Scale
		><Empty
	      /></Scale
	    ></Real
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c06">
      <tc:test-string>7.8e-5</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Real
	      ><Integer
		><Digit>7</Digit
	      ></Integer
	      ><Fraction>.<Integer
              ><Digit>8</Digit
	    ></Integer
	      ></Fraction
	      ><Scale>e<Sign>-</Sign
	      ><Integer
		><Digit>5</Digit
	      ></Integer
	      ></Scale
	    ></Real
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c07">
      <tc:test-string>1.3135633e+6609</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Real
	      ><Integer
		><Digit>1</Digit
	      ></Integer
	      ><Fraction>.<Integer
              ><Integer
		><Integer
		  ><Integer
		    ><Integer
                      ><Integer
			><Integer
			  ><Digit>3</Digit
			></Integer
			><Digit>1</Digit
                      ></Integer
                      ><Digit>3</Digit
		    ></Integer
		    ><Digit>5</Digit
		  ></Integer
		  ><Digit>6</Digit
		></Integer
		><Digit>3</Digit
              ></Integer
              ><Digit>3</Digit
	    ></Integer
	      ></Fraction
	      ><Scale>e<Sign>+</Sign
	      ><Integer
		><Integer
		  ><Integer
		    ><Integer
		      ><Digit>6</Digit
		    ></Integer
		    ><Digit>6</Digit
		  ></Integer
		  ><Digit>0</Digit
		></Integer
		><Digit>9</Digit
	      ></Integer
	      ></Scale
	    ></Real
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g51.c08">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c09">
      <tc:test-string>.99</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c10">
      <tc:test-string>4e+23</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c11">
      <tc:test-string>1.2E23</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c12">
      <tc:test-string>8.413e961</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c13">
      <tc:test-string>8.413e+e</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c14">
      <tc:test-string>8.413e-2.345</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c15">
      <tc:test-string>731.</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c16">
      <tc:test-string>810.8e</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g51.c17">
      <tc:test-string>6.188e+</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.52">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>An awkward grammar for a language with one sentence.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 95 (1e) and 120 (2e).

    They use this grammar to illustrate grammar cleaning (in the course
    of their discussion of CYK parsing).

    "The grammar of Figure 4.10 [4.8 in 1e] is a nasty grammar to text
    your &amp;epsilon;-rule elimination scheme on."
    }

    { Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    }

    S: L, "a", M.
    L: L, M;
       .
    M: M, M;
       .

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
          <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 95 (1e) and 120 (2e).

    They use this grammar to illustrate grammar cleaning (in the course
    of their discussion of CYK parsing).

    "The grammar of Figure 4.10 [4.8 in 1e] is a nasty grammar to text
    your &amp;epsilon;-rule elimination scheme on."
    </comment
            ><comment> Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
                ><nonterminal name="L"
                /><literal string="a"
                /><nonterminal name="M"
              /></alt
            ></rule
            ><rule name="L"
              ><alt
                ><nonterminal name="L"
                /><nonterminal name="M"
              /></alt
              ><alt
            /></rule
            ><rule name="M"
              ><alt
                ><nonterminal name="M"
                /><nonterminal name="M"
              /></alt
              ><alt
            /></rule
          ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g52.c01">
      <tc:test-string>a</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><L/>a<M/></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><L/>a<M><M/><M/></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><L><L/><M/></L>a<M/></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><L><L/><M/></L>a<M><M/><M/></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	    ><L><L><L/><M/></L><M><M/><M/></M></L
	    >a<M><M/><M/></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L
	     />a<M><M><M/><M/></M><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L/><M><M/><M/></M></L
	     >a<M><M/><M/></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L><L/><M/></L><M><M><M/><M/></M><M/></M></L
	     >a<M><M/><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L><L/><M/></L><M><M/><M/></M></L
	     >a<M/></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L/><M><M/><M/></M></L
	     >a<M><M><M/><M/></M><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L/><M><M/><M><M/><M/></M></M></L
	     >a<M><M/><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L><L><L/><M><M/><M/></M></L><M/></L><M/></L
	     >a<M><M><M><M/><M/></M><M/></M><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L/><M/></L
	     >a<M><M><M/><M/></M><M/></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L
	     />a<M><M/><M><M><M/><M/></M><M><M/><M/></M></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L><L/><M><M/><M/></M></L><M><M/><M/></M></L
	     >a<M><M/><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><L><L><L/><M/></L><M><M><M/><M/></M><M><M/><M/></M></M></L
	     >a<M><M><M/><M><M/><M/></M></M><M><M/><M/></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
            ><L><L/><M/></L
            >a<M
            ><M><M><M/><M/></M><M/></M><M><M><M/><M
              ><M><M/><M><M/><M/></M></M><M/></M></M
              ><M><M/><M><M><M/><M><M><M/><M><M/><M
              /></M></M><M><M/><M/></M></M></M><M
              /></M></M></M></M></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	    ><L
	      ><L
		><L
		/><M><M><M><M><M/><M/></M><M/></M><M
                    ><M><M/><M><M><M/><M><M/><M><M
                    /><M/></M></M></M><M/></M></M
                    ><M/></M></M><M/></M
              ></L
	      ><M><M><M><M><M/><M/></M><M><M/><M/></M></M><M/></M><M/></M
            ></L
	    >a<M
	  /></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g52.c02">
      <tc:test-string>aa</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g52.c03">
      <tc:test-string></tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.53">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>Another grammar for the same one-sentence language.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 96 (1e) and 120 (2e).

    They use this grammar to illustrate grammar cleaning (in the course
    of their discussion of CYK parsing); this is the result of applying
    their epsilon-rule elimination scheme to sample grammar 52.

    Its interest here is that it is an example of a machine-generated
    grammar and that it has non-productive and/or unreachable non-terminals.
    (Cleaning the grammar reduces it to the rule S: "a".)

    }

    { Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    }

    S: L1, "a", M1; "a", M1; L1, "a"; "a".
    L: L1, M1; L1; M1; {nil}.
    M: M1, M1; M1; {nil}.
    L1: L1, M1; L1; M1.
    M1: M1, M1; M1.


    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 96 (1e) and 120 (2e).

    They use this grammar to illustrate grammar cleaning (in the course
    of their discussion of CYK parsing); this is the result of applying
    their epsilon-rule elimination scheme to sample grammar 52.

    Its interest here is that it is an example of a machine-generated
    grammar and that it has non-productive and/or unreachable non-terminals.
    (Cleaning the grammar reduces it to the rule S: "a".)

    </comment><comment> Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
		><nonterminal name="L1"
		/><literal string="a"
		/><nonterminal name="M1"
              /></alt
              ><alt
		><literal string="a"
		/><nonterminal name="M1"
              /></alt
              ><alt
		><nonterminal name="L1"
		/><literal string="a"
              /></alt
              ><alt
		><literal string="a"
              /></alt
            ></rule
            ><rule name="L"
              ><alt
		><nonterminal name="L1"
		/><nonterminal name="M1"
              /></alt
              ><alt
		><nonterminal name="L1"
              /></alt
              ><alt
		><nonterminal name="M1"
              /></alt
              ><comment>nil</comment
              ><alt
            /></rule
            ><rule name="M"
              ><alt
		><nonterminal name="M1"
		/><nonterminal name="M1"
              /></alt
              ><alt
		><nonterminal name="M1"
              /></alt
              ><comment>nil</comment
              ><alt
            /></rule
            ><rule name="L1"
              ><alt
		><nonterminal name="L1"
		/><nonterminal name="M1"
              /></alt
              ><alt
		><nonterminal name="L1"
              /></alt
              ><alt
		><nonterminal name="M1"
              /></alt
            ></rule
            ><rule name="M1"
              ><alt
		><nonterminal name="M1"
		/><nonterminal name="M1"
              /></alt
              ><alt
		><nonterminal name="M1"
              /></alt
            ></rule
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:grammar-test>
    <tc:test-case name="g53.c01">
      <tc:test-string>a</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a</S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g53.c02">
      <tc:test-string>b</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g53.r03">
      <tc:test-string></tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.54">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A grammar in Chomsky Normal Form, for numbers in
      scientific notation.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 99 (1e) and 123 (2e).

    This is a Chomsky Normal Form version of sample grammar 51; its
    primary interest for testing ixml parsers is its opacity.
    }

    { Revisions:
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-09 : CMSMcQ : made first transcription.
    }

    Number: ["0" - "9"]
          ; Integer, Digit
          ; N1, Scale1
	  ; Integer, Fraction.
    N1:  Integer, Fraction.
    Integer:  ['0' - '9']; Integer, Digit.
    Fraction: T1, Integer.
    T1 : ".".
    Scale1: N2, Integer.
    N2:  T2, Sign.
    T2:  "e".
    Digit: ['0'-'9'].
    Sign: ["+"; '-' ].

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
          <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 99 (1e) and 123 (2e).

    This is a Chomsky Normal Form version of sample grammar 51; its
    primary interest for testing ixml parsers is its opacity.
    </comment
            ><comment> Revisions:
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="Number"
              ><alt
                ><inclusion
                  ><member from="0" to="9"
                /></inclusion
              ></alt
              ><alt
                ><nonterminal name="Integer"
                /><nonterminal name="Digit"
              /></alt
              ><alt
                ><nonterminal name="N1"
                /><nonterminal name="Scale1"
              /></alt
              ><alt
                ><nonterminal name="Integer"
                /><nonterminal name="Fraction"
              /></alt
            ></rule
            ><rule name="N1"
              ><alt
                ><nonterminal name="Integer"
                /><nonterminal name="Fraction"
              /></alt
            ></rule
            ><rule name="Integer"
              ><alt
                ><inclusion
                  ><member from="0" to="9"
                /></inclusion
              ></alt
              ><alt
                ><nonterminal name="Integer"
                /><nonterminal name="Digit"
              /></alt
            ></rule
            ><rule name="Fraction"
              ><alt
                ><nonterminal name="T1"
                /><nonterminal name="Integer"
              /></alt
            ></rule
            ><rule name="T1"
              ><alt
                ><literal string="."
              /></alt
            ></rule
            ><rule name="Scale1"
              ><alt
                ><nonterminal name="N2"
                /><nonterminal name="Integer"
              /></alt
            ></rule
            ><rule name="N2"
              ><alt
                ><nonterminal name="T2"
                /><nonterminal name="Sign"
              /></alt
            ></rule
            ><rule name="T2"
              ><alt
                ><literal string="e"
              /></alt
            ></rule
            ><rule name="Digit"
              ><alt
                ><inclusion
                  ><member from="0" to="9"
                /></inclusion
              ></alt
            ></rule
            ><rule name="Sign"
              ><alt
                ><inclusion
                  ><member string="+"
                  /><member string="-"
                /></inclusion
              ></alt
            ></rule
          ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g54.c01">
      <tc:test-string>32.5e+1</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><N1
	      ><Integer
		><Integer>3</Integer
		><Digit>2</Digit
	      ></Integer
	      ><Fraction
		><T1>.</T1
		><Integer>5</Integer
	      ></Fraction
	    ></N1
	    ><Scale1
	      ><N2
		><T2>e</T2
		><Sign>+</Sign
	      ></N2
	      ><Integer>1</Integer
	    ></Scale1
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c02">
      <tc:test-string>0</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number>0</Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c03">
      <tc:test-string>21</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer>2</Integer
	    ><Digit>1</Digit
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c04">
      <tc:test-string>67.9</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer
	      ><Integer>6</Integer
	      ><Digit>7</Digit
	    ></Integer
	    ><Fraction
	      ><T1>.</T1
	      ><Integer>9</Integer
	    ></Fraction
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c05">
      <tc:test-string>9978.8024</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer
	      ><Integer
		><Integer
		  ><Integer>9</Integer
		  ><Digit>9</Digit
		></Integer
		><Digit>7</Digit
	      ></Integer
	      ><Digit>8</Digit
	    ></Integer
	    ><Fraction
	      ><T1>.</T1
	      ><Integer
		><Integer
		  ><Integer
		    ><Integer>8</Integer
		    ><Digit>0</Digit
		  ></Integer
		  ><Digit>2</Digit
		></Integer
		><Digit>4</Digit
	      ></Integer
	    ></Fraction
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c06">
      <tc:test-string>7.8e-5</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><N1
	      ><Integer>7</Integer
	      ><Fraction
		><T1>.</T1
		><Integer>8</Integer
	      ></Fraction
	    ></N1
	    ><Scale1
	      ><N2
		><T2>e</T2
		><Sign>-</Sign
	      ></N2
	      ><Integer>5</Integer
	    ></Scale1
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c07">
      <tc:test-string>1.3135633e+6609</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><N1
	      ><Integer>1</Integer
	      ><Fraction
		><T1>.</T1
		><Integer
		  ><Integer
		    ><Integer
		      ><Integer
			><Integer
			  ><Integer
			    ><Integer>3</Integer
			    ><Digit>1</Digit
			  ></Integer
			  ><Digit>3</Digit
			></Integer
			><Digit>5</Digit
		      ></Integer
		      ><Digit>6</Digit
		    ></Integer
		    ><Digit>3</Digit
		  ></Integer
		  ><Digit>3</Digit
		></Integer
	      ></Fraction
	    ></N1
	    ><Scale1
	      ><N2
		><T2>e</T2
		><Sign>+</Sign
	      ></N2
	      ><Integer
		><Integer
		  ><Integer
		    ><Integer>6</Integer
		    ><Digit>6</Digit
		  ></Integer
		  ><Digit>0</Digit
		></Integer
		><Digit>9</Digit
	      ></Integer
	    ></Scale1
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g54.c08">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c09">
      <tc:test-string>.99</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c10">
      <tc:test-string>4e+23</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c11">
      <tc:test-string>1.2E23</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c12">
      <tc:test-string>8.413e961</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c13">
      <tc:test-string>8.413e+e</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c14">
      <tc:test-string>8.413e-2.345</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c15">
      <tc:test-string>731.</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c16">
      <tc:test-string>810.8e</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54.c17">
      <tc:test-string>6.188e+</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.54bis">
    <tc:created on="2022-06-18" by="cmsmcq"/>
    <tc:description>
      <tc:p>The same grammar in Chomsky Normal Form as grammar 54, for
      numbers in scientific notation, but with different ixml
      markings, to see whether CNF makes it harder to make the
      resulting XML look plausible.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 99 (1e) and 123 (2e).

    This is a Chomsky Normal Form version of sample grammar 51; its
    primary interest for testing ixml parsers is its opacity.
    }

    { Revisions:
    2022-06-10 : CMSMcQ : hide some symbols in the output
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-09 : CMSMcQ : made first transcription.
    }

    Number: ["0" - "9"]
          ; -Integer, -Digit
          ; -N1, Scale1
	  ; Integer, Fraction.
    -N1:  Integer, Fraction.
    Integer:  ['0' - '9']; -Integer, -Digit.
    Fraction: -T1, -Integer.
    -T1 : ".".
    Scale1: -N2, Integer.
    -N2:  -T2, Sign.
    -T2:  "e".
    -Digit: ['0'-'9'].
    Sign: ["+"; '-' ].

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 99 (1e) and 123 (2e).

    This is a Chomsky Normal Form version of sample grammar 51; its
    primary interest for testing ixml parsers is its opacity.
    </comment><comment> Revisions:
    2022-06-10 : CMSMcQ : hide some symbols in the output
    2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="Number"
              ><alt
		><inclusion
		  ><member from="0" to="9"
		/></inclusion
              ></alt
              ><alt
		><nonterminal mark="-" name="Integer"
		/><nonterminal mark="-" name="Digit"
              /></alt
              ><alt
		><nonterminal mark="-" name="N1"
		/><nonterminal name="Scale1"
              /></alt
              ><alt
		><nonterminal name="Integer"
		/><nonterminal name="Fraction"
              /></alt
            ></rule
            ><rule mark="-" name="N1"
              ><alt
		><nonterminal name="Integer"
		/><nonterminal name="Fraction"
              /></alt
            ></rule
            ><rule name="Integer"
              ><alt
		><inclusion
		  ><member from="0" to="9"
		/></inclusion
              ></alt
              ><alt
		><nonterminal mark="-" name="Integer"
		/><nonterminal mark="-" name="Digit"
              /></alt
            ></rule
            ><rule name="Fraction"
              ><alt
		><nonterminal mark="-" name="T1"
		/><nonterminal mark="-" name="Integer"
              /></alt
            ></rule
            ><rule mark="-" name="T1"
              ><alt
		><literal string="."
              /></alt
            ></rule
            ><rule name="Scale1"
              ><alt
		><nonterminal mark="-" name="N2"
		/><nonterminal name="Integer"
              /></alt
            ></rule
            ><rule mark="-" name="N2"
              ><alt
		><nonterminal mark="-" name="T2"
		/><nonterminal name="Sign"
              /></alt
            ></rule
            ><rule mark="-" name="T2"
              ><alt
		><literal string="e"
              /></alt
            ></rule
            ><rule mark="-" name="Digit"
              ><alt
		><inclusion
		  ><member from="0" to="9"
		/></inclusion
              ></alt
            ></rule
            ><rule name="Sign"
              ><alt
		><inclusion
		  ><member string="+"
		  /><member string="-"
		/></inclusion
              ></alt
            ></rule
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    
    <tc:test-case name="g54bis.c01">
      <tc:test-string>32.5e+1</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer>32</Integer
	    ><Fraction>.5</Fraction
	    ><Scale1>e<Sign>+</Sign
	    ><Integer>1</Integer
	    ></Scale1
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c02">
      <tc:test-string>0</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number>0</Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c03">
      <tc:test-string>21</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number>21</Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c04">
      <tc:test-string>67.9</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer>67</Integer
	    ><Fraction>.9</Fraction
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c05">
      <tc:test-string>9978.8024</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer>9978</Integer
	    ><Fraction>.8024</Fraction
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c06">
      <tc:test-string>7.8e-5</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer>7</Integer
	    ><Fraction>.8</Fraction
	    ><Scale1>e<Sign>-</Sign
	    ><Integer>5</Integer
	    ></Scale1
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c07">
      <tc:test-string>1.3135633e+6609</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <Number
	    ><Integer>1</Integer
	    ><Fraction>.3135633</Fraction
	    ><Scale1>e<Sign>+</Sign
	    ><Integer>6609</Integer
	    ></Scale1
	  ></Number>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    
    <tc:test-case name="g54bis.c08">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c09">
      <tc:test-string>.99</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c10">
      <tc:test-string>4e+23</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c11">
      <tc:test-string>1.2E23</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c12">
      <tc:test-string>8.413e961</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c13">
      <tc:test-string>8.413e+e</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c14">
      <tc:test-string>8.413e-2.345</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c15">
      <tc:test-string>731.</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c16">
      <tc:test-string>810.8e</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g54bis.c17">
      <tc:test-string>6.188e+</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.55">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A regular grammar.  An equivalent regular expression
      is ac?(bc)*bc?a|aca.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

    This is a regular grammar; C/J use it in their discussion of parsing
    with regular grammars.
    }

    { Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    }

    S: "a", A; "a", B.
    A: "b", B
     ; "b", C.
    B: "c", A
     ; "c", C.
    C: "a".
    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
          <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

    This is a regular grammar; C/J use it in their discussion of parsing
    with regular grammars.
    </comment
            ><comment> Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
                ><literal string="a"
                /><nonterminal name="A"
              /></alt
              ><alt
                ><literal string="a"
                /><nonterminal name="B"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
                ><literal string="b"
                /><nonterminal name="B"
              /></alt
              ><alt
                ><literal string="b"
                /><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
                ><literal string="c"
                /><nonterminal name="A"
              /></alt
              ><alt
                ><literal string="c"
                /><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="C"
              ><alt
                ><literal string="a"
              /></alt
            ></rule
          ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g55.c01">
      <tc:test-string>aca</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>c<C>a</C></B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c02">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c03">
      <tc:test-string>a</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c04">
      <tc:test-string>ac</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c05">
      <tc:test-string>ab</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c06">
      <tc:test-string>abc</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c07">
      <tc:test-string>acb</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c08">
      <tc:test-string>aba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<A>b<C>a</C></A></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c09">
      <tc:test-string>acbcbcbcba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>c<A>b<B>c<A>b<B>c<A>b<B>c<A>b<C>a</C
          ></A></B></A></B></A></B></A></B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c10">
      <tc:test-string>abcbcbcbcba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<A>b<B>c<A>b<B>c<A>b<B>c<A>b<B>c<A>b<C>a</C
          ></A></B></A></B></A></B></A></B></A></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c11">
      <tc:test-string>acbcbcbca</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>c<A>b<B>c<A>b<B>c<A>b<B>c<C>a</C
          ></B></A></B></A></B></A></B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g55.c12">
      <tc:test-string>abcbcbcbca</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<A>b<B>c<A>b<B>c<A>b<B>c<A>b<B>c<C>a</C
          ></B></A></B></A></B></A></B></A></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.56">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A grammar with undefined, unproductive, and unreachable
      nonterminals.</tc:p>
      <tc:p>Alternate expected results are given for processors
      running with an option to tolerate multiple definitions
      and undefined symbols.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

    This is an augmented form of the regular grammar in 55, intended to
    illustrate the existence of undefined, unproductive, and unreachable
    non-terminals in regular grammars.
    }

    { Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    }

    S: "a", A; "a", B.
    A: "b", B.
    A: "b", C.
    B: "c", A.
    B: "c", C.
    C: "a".

    B: "c", D. { undefined }
    B: "c", E.
    E: "e", E. { unproductive }
    F: "f", A.  { unreachable }
    F: "h".


    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-not-a-grammar error-code="S02 S03"/>
      </tc:result>

      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:assert-xml>

          <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

    This is an augmented form of the regular grammar in 55, intended to
    illustrate the existence of undefined, unproductive, and unreachable
    non-terminals in regular grammars.
    </comment
            ><comment> Revisions:
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
                ><literal string="a"
                /><nonterminal name="A"
              /></alt
              ><alt
                ><literal string="a"
                /><nonterminal name="B"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
                ><literal string="b"
                /><nonterminal name="B"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
                ><literal string="b"
                /><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
                ><literal string="c"
                /><nonterminal name="A"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
                ><literal string="c"
                /><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="C"
              ><alt
                ><literal string="a"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
                ><literal string="c"
                /><nonterminal name="D"
              /></alt
            ></rule
            ><comment> undefined </comment
            ><rule name="B"
              ><alt
                ><literal string="c"
                /><nonterminal name="E"
              /></alt
            ></rule
            ><rule name="E"
              ><alt
                ><literal string="e"
                /><nonterminal name="E"
              /></alt
            ></rule
            ><comment> unproductive </comment
            ><rule name="F"
              ><alt
                ><literal string="f"
                /><nonterminal name="A"
              /></alt
            ></rule
            ><comment> unreachable </comment
            ><rule name="F"
              ><alt
                ><literal string="h"
              /></alt
            ></rule
          ></ixml>	  
	</tc:assert-xml>
      </tc:app-info>
    </tc:grammar-test>
    <tc:test-case name="g56.c01">
      <tc:test-string>aca</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result>
	  <tc:assert-xml>
	    <S>a<B>c<C>a</C></B></S>
	  </tc:assert-xml>
	</tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c02">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result><tc:assert-not-a-sentence/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c03">
      <tc:test-string>a</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result><tc:assert-not-a-sentence/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c04">
      <tc:test-string>ac</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result><tc:assert-not-a-sentence/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c05">
      <tc:test-string>ab</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result><tc:assert-not-a-sentence/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c06">
      <tc:test-string>abc</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result><tc:assert-not-a-sentence/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c07">
      <tc:test-string>acb</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result><tc:assert-not-a-sentence/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c08">
      <tc:test-string>aba</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result>
	  <tc:assert-xml>
	    <S>a<A>b<C>a</C></A></S>
	  </tc:assert-xml>
	</tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c09">
      <tc:test-string>acbcbcbcba</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result>
	  <tc:assert-xml>
	    <S>a<B>c<A>b<B>c<A>b<B>c<A>b<B>c<A>b<C>a</C
              ></A></B></A></B></A></B></A></B></S>
	  </tc:assert-xml>
	</tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c10">
      <tc:test-string>abcbcbcbcba</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result>
	  <tc:assert-xml>
	    <S>a<A>b<B>c<A>b<B>c<A>b<B>c<A>b<B>c<A>b<C>a</C
              ></A></B></A></B></A></B></A></B></A></S>
	  </tc:assert-xml>
      </tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c11">
      <tc:test-string>acbcbcbca</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result>
	  <tc:assert-xml>
	    <S>a<B>c<A>b<B>c<A>b<B>c<A>b<B>c<C>a</C
              ></B></A></B></A></B></A></B></S>
	  </tc:assert-xml>
	</tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56.c12">
      <tc:test-string>abcbcbcbca</tc:test-string>
      <tc:result><tc:assert-not-a-grammar error-code="S02 S03"/></tc:result>
      <tc:app-info>
	<tc:options ap:multiple-definitions="warning"
		    ap:undefined-symbols="warning"/>
	<tc:options ap:multiple-definitions="silence"
		    ap:undefined-symbols="silence"/>
	<tc:result>
	  <tc:assert-xml>
	    <S>a<A>b<B>c<A>b<B>c<A>b<B>c<A>b<B>c<C>a</C
              ></B></A></B></A></B></A></B></A></S>
	  </tc:assert-xml>
	</tc:result>
      </tc:app-info>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.56bis">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:modified on="2022-06-16" by="cmsmcq"
		 change="merged multiple definitions"/>
    <tc:description>
      <tc:p>Modified version of grammar 56.</tc:p>
      <tc:p>Definitions of A, B, and F have been merged, reference to
      undefined nonterminal D has been replaced by an unsatisfiable
      reference to an empty character set, but unproductive
      nonterminal E and unreachable nonterminal F remain.</tc:p>
      <tc:p>Unlike grammar 56, this grammar is conformant.</tc:p>
      <tc:p>Alternate expected results are given for processors
      running either with an option to treat unreachable symbols
      as errors or an option to treat unproductive nonterminals
      as errors.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

    This is an augmented form of the regular grammar in 55, intended to
    illustrate the existence of undefined, unproductive, and unreachable
    non-terminals in regular grammars.
    }

    { Revisions:
    2022-06-16 : CMSMcQ : made revised version.
    2018-08-09 : CMSMcQ : made first transcription.
    }

    S: "a", A; "a", B.
    A: "b", B; "b", C.
    B: "c", A; "c", C; "c", []; "c", E.
    
    C: "a".

    E: "e", E. { unproductive }
    F: "f", A; "h".  { unreachable }

    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
          <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

    This is an augmented form of the regular grammar in 55, intended to
    illustrate the existence of undefined, unproductive, and unreachable
    non-terminals in regular grammars.
    </comment
            ><comment> Revisions:
    2022-06-16 : CMSMcQ : made revised version.
    2018-08-09 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
                ><literal string="a"
                /><nonterminal name="A"
              /></alt
              ><alt
                ><literal string="a"
                /><nonterminal name="B"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
                ><literal string="b"
                /><nonterminal name="B"
              /></alt
              ><alt
                ><literal string="b"
                /><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
                ><literal string="c"
                /><nonterminal name="A"
              /></alt
              ><alt
                ><literal string="c"
                /><nonterminal name="C"
              /></alt
              ><alt
                ><literal string="c"
                /><inclusion
              /></alt
              ><alt
                ><literal string="c"
                /><nonterminal name="E"
              /></alt
            ></rule
            ><rule name="C"
              ><alt
                ><literal string="a"
              /></alt
            ></rule
            ><rule name="E"
              ><alt
                ><literal string="e"
                /><nonterminal name="E"
              /></alt
            ></rule
            ><comment> unproductive </comment
            ><rule name="F"
              ><alt
                ><literal string="f"
                /><nonterminal name="A"
              /></alt
              ><alt
                ><literal string="h"
              /></alt
            ></rule
            ><comment> unreachable </comment
          ></ixml>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:grammar-test>
    <tc:test-case name="g56bis.c01">
      <tc:test-string>aca</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>c<C>a</C></B></S>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c02">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g56bis.c03">
      <tc:test-string>a</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c04">
      <tc:test-string>ac</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c05">
      <tc:test-string>ab</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c06">
      <tc:test-string>abc</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c07">
      <tc:test-string>acb</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c08">
      <tc:test-string>aba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<A>b<C>a</C></A></S>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c09">
      <tc:test-string>acbcbcbcba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>c<A>b<B>c<A>b<B>c<A>b<B>c<A>b<C>a</C
            ></A></B></A></B></A></B></A></B></S>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c10">
      <tc:test-string>abcbcbcbcba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<A>b<B>c<A>b<B>c<A>b<B>c<A>b<B>c<A>b<C>a</C
            ></A></B></A></B></A></B></A></B></A></S>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c11">
      <tc:test-string>acbcbcbca</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>c<A>b<B>c<A>b<B>c<A>b<B>c<C>a</C
            ></B></A></B></A></B></A></B></S>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
    <tc:test-case name="g56bis.c12">
      <tc:test-string>abcbcbcbca</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<A>b<B>c<A>b<B>c<A>b<B>c<A>b<B>c<C>a</C
            ></B></A></B></A></B></A></B></A></S>
	</tc:assert-xml>
      </tc:result>
      <tc:app-info>
	<tc:options ap:unreachable-symbols="error"/>
	<tc:options ap:unproductive-symbols="error"/>
	<tc:result><tc:assert-not-a-grammar/></tc:result>
      </tc:app-info>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.57">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A grammar for strings with equal numbers of a and b.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 119 (1e) and 165 (2e).

    "This grammar produces sentences with equal numbers of *a*s and *b*s."

    }

    { Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    }

    S: "a", B; "b", A.
    A: "a"; "a", S; "b", A, A.
    B: "b"; "b", S; "a", B, B.
    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), pp. 119 (1e) and 165 (2e).

    "This grammar produces sentences with equal numbers of *a*s and *b*s."

    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
		><literal string="a"
		/><nonterminal name="B"
              /></alt
              ><alt
		><literal string="b"
		/><nonterminal name="A"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
		><literal string="a"
              /></alt
              ><alt
		><literal string="a"
		/><nonterminal name="S"
              /></alt
              ><alt
		><literal string="b"
		/><nonterminal name="A"
		/><nonterminal name="A"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
		><literal string="b"
              /></alt
              ><alt
		><literal string="b"
		/><nonterminal name="S"
              /></alt
              ><alt
		><literal string="a"
		/><nonterminal name="B"
		/><nonterminal name="B"
              /></alt
            ></rule
	  ></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g57.c01">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c02">
      <tc:test-string>ab</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>b</B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c03">
      <tc:test-string>abba</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S>a<B>b<S>b<A>a</A></S></B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c04">
      <tc:test-string>aaaaabbbbab</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c05">
      <tc:test-string>aaabaabbabbb</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>b</B><B>a<B>a<B>b</B
             ><B>b</B></B><B>a<B>b</B><B>b</B
             ></B></B></B><B>b</B></B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
             >a<B>a<B>a<B>b</B><B>a<B>a<B>b<S>b<A
             >a</A></S></B><B>b</B></B><B>b</B
             ></B></B><B>b</B></B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>b</B><B>a<B>a<B>b</B><B
             >b<S>a<B>b</B></S></B></B><B>b</B></B
             ></B><B>b</B></B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>b<S>a<B>a<B>b</B><B>b<S
             >a<B>b</B></S></B></B></S></B><B>b</B
             ></B><B>b</B></B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>b<S>a<B>a<B>b</B><B>b</B
	     ></B></S></B><B>a<B>b</B><B>b</B></B
	     ></B><B>b</B></B
	  ></S>
	</tc:assert-xml>
        <tc:assert-xml>
          <S ixml:state="ambiguous">a<B>a<B>a<B>b<S>a<B>a<B>b<S>b<A>a</A
             ></S></B><B>b</B></B></S></B><B>b</B
             ></B><B>b</B></B
          ></S>
        </tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c06">
      <tc:test-string>aaaabbbabb</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>a<B>b</B><B>b<S>b<A>a</A
             ></S></B></B><B>b</B></B><B>b</B></B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>a<B>b</B><B>b</B></B><B
             >b<S>a<B>b</B></S></B></B><B>b</B></B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>a<B>b</B><B>b</B></B><B
             >b</B></B><B>a<B>b</B><B>b</B></B></B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>a<B>a<B>a<B>b</B><B>b</B></B><B
             >b</B></B><B>a<B>b</B><B>b</B></B></B
          ></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c07">
      <tc:test-string>aaaaaaaaaa</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c08">
      <tc:test-string>babababb</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c09">
      <tc:test-string>baobab</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g57.c10">
      <tc:test-string>abbaaabbbbaaaabbbaab</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>b<S>b<A>a<S>a<B>a<B>b<S>b<A>b<A
             >b<A>a</A><A>a</A></A><A>a</A></A></S
             ></B><B>a<B>b<S>b<A>b<A>a</A><A>a</A
             ></A></S></B><B>b</B></B></B></S></A
             ></S></B
           ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>b<S>b<A>a<S>a<B>a<B>b<S>b<A>b<A
             >b<A>a</A><A>a</A></A><A>a</A></A></S
             ></B><B>a<B>b</B><B>b<S>b<A>a<S>a<B
             >b</B></S></A></S></B></B></B></S></A
             ></S></B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>b<S>b<A>a<S>a<B>a<B>b<S>b<A>b<A
             >b<A>a</A><A>a</A></A><A>a<S>a<B>b<S
             >b<A>b<A>a</A><A>a</A></A></S></B></S
             ></A></A></S></B><B>b</B></B></S></A
             ></S></B
           ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>b<S>b<A>a<S>a<B>a<B>b<S>b<A>b<A
	     >b<A>a</A><A>a<S>a<B>a<B>b</B><B>b<S
             >b<A>a</A></S></B></B></S></A></A><A
             >a</A></A></S></B><B>b</B></B></S></A
             ></S></B
           ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     >a<B>b<S>b<A>a<S>a<B>a<B>b<S>b<A>b<A
             >b<A>a</A><A>a</A></A><A>a<S>a<B>b</B
             ></S></A></A></S></B><B>b<S>b<A>a<S
             >a<B>b</B></S></A></S></B></B></S></A
             ></S></B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
             >a<B>b<S>b<A>a<S>a<B>a<B>b<S>b<A>b<A
             >b<A>a<S>a<B>a<B>a<B>b</B><B>b</B></B
             ><B>b</B></B></S></A><A>a</A></A><A
             >a</A></A></S></B><B>b</B></B></S></A
             ></S></B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
             >a<B>b<S>b<A>a<S>a<B>a<B>b</B><B>b<S
             >b<A>b<A>a</A><A>a<S>a<B>a<B>b</B><B
             >b<S>b<A>a<S>a<B>b</B></S></A></S></B
             ></B></S></A></A></S></B></B></S></A
             ></S></B></S>
        </tc:assert-xml>
      </tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.58">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A grammar for the string 'abc'.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), p. 49 (2e).

    "A demo grammar for grammar cleaning"
    }

    { Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    }

    S: A, B; D, E.
    A: "a".
    B: "b", C.
    C: "c".
    D: "d", F.
    E: "e".
    F: "f", D.

    { After removal of non-productive rules, this becomes

    S: A, B.
    A: "a".
    B: "b", C.
    C: "c".
    E: "e".

    E is now unreachable and its rule can be removed.

    }</tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), p. 49 (2e).

    "A demo grammar for grammar cleaning"
    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    </comment
          ><rule name="S"
            ><alt
              ><nonterminal name="A"
              /><nonterminal name="B"
            /></alt
            ><alt
              ><nonterminal name="D"
              /><nonterminal name="E"
            /></alt
          ></rule
          ><rule name="A"
            ><alt
              ><literal string="a"
            /></alt
          ></rule
          ><rule name="B"
            ><alt
              ><literal string="b"
              /><nonterminal name="C"
            /></alt
          ></rule
          ><rule name="C"
            ><alt
              ><literal string="c"
            /></alt
          ></rule
          ><rule name="D"
            ><alt
              ><literal string="d"
              /><nonterminal name="F"
            /></alt
          ></rule
          ><rule name="E"
            ><alt
              ><literal string="e"
            /></alt
          ></rule
          ><rule name="F"
            ><alt
              ><literal string="f"
              /><nonterminal name="D"
            /></alt
          ></rule
          ><comment> After removal of non-productive rules, this becomes

    S: A, B.
    A: "a".
    B: "b", C.
    C: "c".
    E: "e".

    E is now unreachable and its rule can be removed.

    </comment></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g58.c01">
      <tc:test-string>abc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S><A>a</A><B>b<C>c</C></B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g58.c02">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g58.c03">
      <tc:test-string>ab</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g58.c04">
      <tc:test-string>aabcc</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g58.c05">
      <tc:test-string>cba</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.59">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>Grammar for an inherently ambiguous language.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), p. 49 (2e).

    "Grammar for an inherently ambiguous language"

    The language consists of all sequences a^m + b^n + c^n
    unioned with a^p + b^p + c^q.
    }

    { Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    }

    S: A, B; D, C.
    A: "a"; "a", A.
    B: "b", "c"; "b", B, "c".
    D: "a", "b"; "a", D, "b".
    C: "c"; "c", C.

    { sample grammar 60 is a recasting of this in idiomatic EBNF. }
    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), p. 49 (2e).

    "Grammar for an inherently ambiguous language"

    The language consists of all sequences a^m + b^n + c^n
    unioned with a^p + b^p + c^q.
    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
		><nonterminal name="A"
		/><nonterminal name="B"
              /></alt
              ><alt
		><nonterminal name="D"
		/><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
		><literal string="a"
              /></alt
              ><alt
		><literal string="a"
		/><nonterminal name="A"
              /></alt
            ></rule
            ><rule name="B"
              ><alt
		><literal string="b"
		/><literal string="c"
              /></alt
              ><alt
		><literal string="b"
		/><nonterminal name="B"
		/><literal string="c"
              /></alt
            ></rule
            ><rule name="D"
              ><alt
		><literal string="a"
		/><literal string="b"
              /></alt
              ><alt
		><literal string="a"
		/><nonterminal name="D"
		/><literal string="b"
              /></alt
            ></rule
            ><rule name="C"
              ><alt
		><literal string="c"
              /></alt
              ><alt
		><literal string="c"
		/><nonterminal name="C"
              /></alt
            ></rule
            ><comment> sample grammar 60 is a recasting of this in idiomatic EBNF. </comment></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g59.c01">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g59.c02">
      <tc:test-string>abc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><A>a</A><B>bc</B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><D>ab</D><C>c</C></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g59.c03">
      <tc:test-string>aaabbbccc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><A>a<A>a<A>a</A></A></A><B>b<B>b<B>bc</B>c</B>c</B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><D>a<D>a<D>ab</D>b</D>b</D><C>c<C>c<C>c</C></C></C></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g59.c04">
      <tc:test-string>aaaaaaabbbbbbbccccccc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><A>a<A>a<A>a<A>a<A>a<A>a<A>a</A
             ></A></A></A></A></A></A
             ><B>b<B>b<B>b<B>b<B>b<B>b<B
             >bc</B>c</B>c</B>c</B>c</B>c</B>c</B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><D>a<D>a<D>a<D>a<D>a<D>a<D
             >ab</D>b</D>b</D>b</D>b</D>b</D>b</D
	     ><C>c<C>c<C>c<C>c<C>c<C>c<C>c</C
             ></C></C></C></C></C></C
          ></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g59.c05">
      <tc:test-string>aaabbcc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S><A>a<A>a<A>a</A></A></A><B>b<B>bc</B>c</B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g59.c06">
      <tc:test-string>aaabbbcccc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S
             ><D>a<D>a<D>ab</D>b</D>b</D
             ><C>c<C>c<C>c<C>c</C></C></C></C
          ></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g59.c07">
      <tc:test-string>aaaabbbcccc</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>

  <tc:test-set name="sample.grammar.60">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>Another grammar for the same inherently ambiguous
      language, using EBNF style.</tc:p>
    </tc:description>
    <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), p. 49 (2e).

    "Grammar for an inherently ambiguous language"

    The language consists of all sequences a^m + b^n + c^n
    unioned with a^p + b^p + c^q.
    }

    { Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    }

    S: A, B; D, C.
    A: "a"+.
    B: "b", "c"; "b", B, "c".
    D: "a", "b"; "a", D, "b".
    C: "c"+.

    { This is a recasting of grammar 59 in idiomatic EBNF.
    Grune and Jacobs repeat this grammar (p. 171) and use it
    as an example when discussing general parsing methods.
    }
    </tc:ixml-grammar>
    <tc:grammar-test>
      <tc:result>
	<tc:assert-xml>
	  <ixml
            ><comment> Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
    Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
    second edition New York:  Springer, 2008), p. 49 (2e).

    "Grammar for an inherently ambiguous language"

    The language consists of all sequences a^m + b^n + c^n
    unioned with a^p + b^p + c^q.
    </comment><comment> Revisions:
    2018-08-10 : CMSMcQ : made first transcription.
    </comment
            ><rule name="S"
              ><alt
		><nonterminal name="A"
		/><nonterminal name="B"
              /></alt
              ><alt
		><nonterminal name="D"
		/><nonterminal name="C"
              /></alt
            ></rule
            ><rule name="A"
              ><alt
		><repeat1
		  ><literal string="a"
		/></repeat1
              ></alt
            ></rule
            ><rule name="B"
              ><alt
		><literal string="b"
		/><literal string="c"
              /></alt
              ><alt
		><literal string="b"
		/><nonterminal name="B"
		/><literal string="c"
              /></alt
            ></rule
            ><rule name="D"
              ><alt
		><literal string="a"
		/><literal string="b"
              /></alt
              ><alt
		><literal string="a"
		/><nonterminal name="D"
		/><literal string="b"
              /></alt
            ></rule
            ><rule name="C"
              ><alt
		><repeat1
		  ><literal string="c"
		/></repeat1
              ></alt
            ></rule
            ><comment> This is a recasting of grammar 59 in idiomatic EBNF.
    Grune and Jacobs repeat this grammar (p. 171) and use it
    as an example when discussing general parsing methods.
    </comment></ixml>
	</tc:assert-xml>
      </tc:result>
    </tc:grammar-test>
    <tc:test-case name="g60.c01">
      <tc:test-string/>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
    <tc:test-case name="g60.c02">
      <tc:test-string>abc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><A>a</A><B>bc</B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><D>ab</D><C>c</C></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g60.c03">
      <tc:test-string>aaabbbccc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><A>aaa</A><B>b<B>b<B>bc</B>c</B>c</B></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"><D>a<D>a<D>ab</D>b</D>b</D><C>ccc</C></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g60.c04">
      <tc:test-string>aaaaaaabbbbbbbccccccc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><A>aaaaaaa</A
             ><B>b<B>b<B>b<B>b<B>b<B>b<B
             >bc</B>c</B>c</B>c</B>c</B>c</B>c</B
          ></S>
	</tc:assert-xml>
	<tc:assert-xml>
	  <S ixml:state="ambiguous"
	     ><D>a<D>a<D>a<D>a<D>a<D>a<D
             >ab</D>b</D>b</D>b</D>b</D>b</D>b</D
	     ><C>ccccccc</C
          ></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g60.c05">
      <tc:test-string>aaabbcc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S><A>aaa</A><B>b<B>bc</B>c</B></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g60.c06">
      <tc:test-string>aaabbbcccc</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <S
             ><D>a<D>a<D>ab</D>b</D>b</D
             ><C>cccc</C
          ></S>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g60.c07">
      <tc:test-string>aaaabbbcccc</tc:test-string>
      <tc:result><tc:assert-not-a-sentence/></tc:result>
    </tc:test-case>
  </tc:test-set>


</tc:test-catalog>
