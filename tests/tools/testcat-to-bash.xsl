<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:tc="https://github.com/invisibleXML/ixml/test-catalog"
                xmlns:tctb="https://github.com/invisibleXML/ixml/tools/testcat-to-bash.xsl"
		xmlns:ixml="http://invisiblexml.org/NS"
                xmlns:t="http://blackmesatech.com/2022/iXML/test-harness"
                version="3.0">

  <!-- testcat-to-bash:  simple stylesheet to read a test catalog
       and generate a bash file to run all tests and produce a test
       report.
  -->
  <!-- Assumptions:
       
       * Assumes that the ixml processor being tested can be invoked
       with three arguments:  input file, grammar file, output file.
       (In practice, I write a wrapper shell script to make this so.)

       * Assumes that the Gnu 'time' command is available.  (It's used
       for the sake of its -o option; if it's necessary to use a
       built-in 'time' command, the invocation of the parse command
       will need to be changed.)

       * Assumes the resulting Bash file will be run in a directory
       
  -->
  
  <!-- Known limitations / shortcomings / to-do list:
       
       * Current version does not actually check to see whether the
       output of the test is correct or not.

       * The current version does not follow references to external
       test sets.

       * The current version works with the bash on the development
       machine.  It may or may not work with other shells.

       * The bash script emitted by the current version has no sanity
       checks.  If something goes wrong, who knows what will happen.

  -->

  <!-- Revisions:
       2023-11-21 : CMSMcQ : make first version of this transform
  -->

  <xsl:output method="text" />

  <xsl:strip-space elements="*"/>
  <xsl:preserve-space elements="tc:assert-xml"
                      />

  <xsl:variable name="tctb:ver" as="xs:string"
                select=" 'v0.0' "/>  

  <!-- User-supplied parameters:
       PROCESSOR (full name of processor)
       PROCVER (processor version label)
       PROC (optional single-token short form of processor name)
       CMD (optional command for parsing)
       OUTDIR (optional path to directory in which to put output)
       OUTPUT (optional filename for report)
       -->
  <xsl:param name="PROCESSOR" as="xs:string"/>            
  <xsl:param name="PROCVER" as="xs:string"/>            
  <xsl:param name="PROC" as="xs:string" select="translate('$PROCESSOR', ' ', '_')"/>
  <xsl:param name="CMD" as="xs:string" select=" 'ixml' "/>
  
  <xsl:variable name="DATE" as="xs:date"
                select="adjust-date-to-timezone(current-date(), ())"/>
  <xsl:variable name="DATETIME" as="xs:dateTime"
                select="adjust-dateTime-to-timezone(current-dateTime(), ())"/>

  <xsl:param name="OUTDIR" as="xs:string"
             select="concat(
                     $PROC,
                     '-results'
                     )"/>

  <xsl:param name="OUTPUT" as="xs:string"
             select="concat(
                     'test-report.',
                     $DATETIME,
                     '.xml'
                     )"/>

  <!--****************************************************************
      * 1.  Document element: tc:test-report
      ****************************************************************
      *-->
  
  <xsl:template match="tc:test-catalog">
    <xsl:call-template name="emit-header"/>
    <xsl:call-template name="emit-start-of-report"/>
    <xsl:apply-templates select="tc:test-set"/>
    <xsl:call-template name="emit-end-of-report"/>
  </xsl:template>

  
  <!--****************************************************************
      * 2.  Emit report framework (start, end)
      ****************************************************************
      *-->

  <!-- emit-header:  Bash comments and internal identification -->
  <xsl:template name="emit-header">
    <xsl:text># Test harness generated by testcat-to-bash.xsl.</xsl:text>
    <xsl:text>&#xA;# Source: </xsl:text>
    <xsl:value-of select="base-uri(.)"/>
    <xsl:text>&#xA;# Date: </xsl:text>
    <xsl:value-of select="$DATETIME"/>
    <xsl:text>&#xA;</xsl:text>
    <xsl:text>&#xA;IXML=</xsl:text>
    <xsl:value-of select="$CMD"/>
    <xsl:text>&#xA;</xsl:text>    
  </xsl:template>
  
  <!-- emit-start-of-report:  First part of test report -->
  <!-- N.B. tc:test-catalog is current element -->
  <xsl:template name="emit-start-of-report">
    
    <xsl:text>&#xA;# 1 Start the test-report document</xsl:text>
    <!--* make the directory if it does not already exist.
        * No error if it does.
        *-->
    <xsl:if test="$OUTDIR ne ''">
      <xsl:text>&#xA;mkdir --parents </xsl:text>
      <xsl:value-of select="$OUTDIR"/>
    </xsl:if>

    <!--* echo the start of the test report document to it. *-->
    <xsl:text>&#xA;echo "&lt;tc:test-report</xsl:text>
    <xsl:text>&#xA;    xmlns:t=\"http://blackmesatech.com/2022/iXML/test-harness\"</xsl:text>
    <xsl:text>&#xA;    xmlns:tc=\"https://github.com/invisibleXML/ixml/test-catalog\"</xsl:text>
    <xsl:text>&#xA;    t:creator=\"testcat-to-bash.xsl </xsl:text>
      <xsl:value-of select="$tctb:ver"/>
      <xsl:text>\"></xsl:text>
    <xsl:text>&#xA;  &lt;tc:metadata></xsl:text>
    <xsl:text>&#xA;    &lt;tc:name>Test results for catalog '</xsl:text>
      <xsl:value-of select="string(@name)"/>
      <xsl:text>'&lt;/tc:name></xsl:text>
    <xsl:text>&#xA;    &lt;tc:report-date></xsl:text>
      <xsl:value-of select="$DATETIME"/>
      <xsl:text>&lt;/tc:report-date></xsl:text>
    <xsl:text>&#xA;    &lt;tc:processor></xsl:text>
      <xsl:value-of select="$PROCESSOR"/>
      <xsl:text>&lt;/tc:processor></xsl:text>
    <xsl:text>&#xA;    &lt;tc:processor-version></xsl:text>
      <xsl:value-of select="$PROCVER"/>
      <xsl:text>&lt;/tc:processor-version></xsl:text>
    <xsl:text>&#xA;    &lt;tc:catalog-uri></xsl:text>
      <xsl:value-of select="base-uri(.)"/>
      <xsl:text>&lt;/tc:catalog-uri></xsl:text>
    <xsl:text>&#xA;    &lt;tc:catalog-date></xsl:text>
      <xsl:value-of select="@release-date"/>
      <xsl:text>&lt;/tc:catalog-date></xsl:text>
    <xsl:text>&#xA;    &lt;tc:description></xsl:text>
    <xsl:text>&#xA;      &lt;tc:p>Test report generated by testcat-to-bash.xsl </xsl:text>
      <xsl:value-of select="$tctb:ver"/>
      <xsl:text>.&lt;/tc:p></xsl:text>
    <xsl:text>&#xA;    &lt;/tc:description></xsl:text>
    <xsl:text>&#xA;  &lt;/tc:metadata></xsl:text>
    <xsl:text>&#xA;  &lt;tc:description></xsl:text>
    <!-- !!! When we start checking test results, the following should change. !!! -->
    <xsl:text>&#xA;    &lt;tc:p>N.B. Tests run for timing only, results assumed OK&lt;/tc:p></xsl:text>
    <xsl:text>&#xA;  &lt;/tc:description></xsl:text>    
    <xsl:text>&#xA;</xsl:text>
    <xsl:text>&#xA;" > </xsl:text>
    <xsl:value-of select="concat($OUTDIR, '/', $OUTPUT)"/>
  </xsl:template>
  
  <!-- emit-end-of-report:  Final part of test report -->
  <xsl:template name="emit-end-of-report">    
    <!--* echo-append the end of the test report document. *-->
    <xsl:text>&#xA;echo "</xsl:text>
    <xsl:text>&#xA;&lt;/tc:test-report></xsl:text>
    <xsl:text>&#xA;" >> </xsl:text>
    <xsl:value-of select="concat($OUTDIR, '/', $OUTPUT)"/>
  </xsl:template>

  
  <!--****************************************************************
      * 3.  Process test sets
      ****************************************************************
      *-->
  
  <!-- For now, we skip external references. Sufficient unto the day ... -->  
  <xsl:template match="tc:test-set-ref">
    <xsl:message>
      <xsl:text>! Skipping external test set reference to </xsl:text>
      <xsl:text>&#xA;    </xsl:text>
      <xsl:value-of select="@href"/>
      <xsl:text>&#xA;for now.</xsl:text>
    </xsl:message>
  </xsl:template>

  <!--* Handle a test set *-->
  <xsl:template match="tc:test-set">
    <!--* Nested test sets may inherit grammars *-->
    <xsl:param name="uriG" tunnel="yes"/>
    
    <xsl:message>
      <xsl:text>Processing internal test set '</xsl:text>
      <xsl:value-of select="@name"/>
      <xsl:text>' ...</xsl:text>
    </xsl:message>

    <!--* Where is the grammar?  We need to pass the URI
        * down to the test cases *-->

    <xsl:variable name="tctb:default-uri">
      <xsl:sequence 
          select="concat(
                  if ($OUTDIR eq '')
                  then ''
                  else concat($OUTDIR, '/'),
                  'grammar.',
                  translate(@name, ' ', '_'),
                  '.ixml')"/>
    </xsl:variable>
    <xsl:variable name="uriG-local">
      <xsl:choose>
        <xsl:when test="tc:ixml-grammar-ref">
          <xsl:sequence 
              select="resolve-uri(tc:ixml-grammar-ref/@href,
                      base-uri(.))"/>
        </xsl:when>
        <xsl:when test="tc:ixml-grammar">
          <xsl:sequence 
              select="$tctb:default-uri"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$uriG"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!--* If the grammar is given in the test catalog, we need to
        * write it out at the URI we specified for it. *-->
    <xsl:apply-templates select="tc:ixml-grammar"
                         mode="write-to-file">
      <xsl:with-param name="uri" select="$tctb:default-uri"/>
    </xsl:apply-templates>

    <!-- Assertion: grammar is at $uriG -->
    <xsl:message>
      <xsl:text>   Grammar for '</xsl:text>
      <xsl:value-of select="@name"/>
      <xsl:text>' is at: </xsl:text>
      <xsl:value-of select="$uriG-local"/>
    </xsl:message>

    <xsl:text>&#xA;# * Test set </xsl:text>
    <xsl:value-of select="@name"/>

    <!-- start test-set-results element -->
    <xsl:text>&#xA;&#xA;echo '&lt;tc:test-set-results name="</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>">' >> </xsl:text>
    <xsl:value-of select="concat($OUTDIR, '/', $OUTPUT)"/>  
    
    <!-- Handle children:  grammar test if any,
         test cases if any, nested test sets if any -->
    <xsl:apply-templates select="tc:grammar-test
                                 | tc:test-case
                                 | tc:test-set">
      <xsl:with-param name="uriG"
                      select="tctb:uri-to-path($uriG-local)"
                      tunnel="yes"/>
      <xsl:with-param name="nmTS"
                      select="string(@name)"/>
    </xsl:apply-templates>

    <!-- end test-set-results element -->
    <xsl:text>&#xA;&#xA;echo '&lt;/tc:test-set-results>&lt;!-- </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>-->' >> </xsl:text>
    <xsl:value-of select="concat($OUTDIR, '/', $OUTPUT)"/>
    
    <!-- Say goodnight, Gracie -->
    <xsl:message>
      <xsl:text>... done with test set '</xsl:text>
      <xsl:value-of select="@name"/>
      <xsl:text>'.</xsl:text>
    </xsl:message>
  </xsl:template>
  

  <!--****************************************************************
      * 4.  Process test cases
      ****************************************************************
      *-->
  
  <xsl:template match="tc:grammar-test">
    <xsl:message>
      <xsl:text>Skipping grammar test in test set </xsl:text>
      <xsl:value-of select="parent::*/@name"/>
      <xsl:text> for now.  (To be fixed later.)</xsl:text>
    </xsl:message>    
  </xsl:template>
  
  <xsl:template match="tc:test-case">
    <xsl:param name="uriG" tunnel="yes" required="yes"/>
    <xsl:param name="nmTS" tunnel="no"  required="yes"/>

    <xsl:variable name="idTC" as="xs:string"
                  select="concat($nmTS, '...', @name)"/>
    
    <xsl:message>
      <xsl:text>  - Test case </xsl:text>
      <xsl:value-of select="$idTC"/>
      <xsl:text> ...</xsl:text>
    </xsl:message>

    <!--* We want to invoke the processor with the pattern:
        * $CMD $input $grammar $output
        * (wrapped in /usr/bin/time ...)
        *
        * So we need input and output file names.
        * The grammar is in $uriG
        *-->

    <!-- Where is the input? -->
    <xsl:variable name="tctb:default-uri">
      <xsl:sequence 
          select="concat(
                  if ($OUTDIR eq '')
                  then ''
                  else concat($OUTDIR, '/'),
                  'input.',
                  $idTC,
                  '.txt')"/>
    </xsl:variable> 
    <xsl:variable name="uriS">
      <xsl:choose>
        <xsl:when test="tc:test-string-ref">
          <xsl:sequence 
              select="tctb:uri-to-path(
                      resolve-uri(tc:test-string-ref/@href,
                      base-uri(.))
                      )"/>
        </xsl:when>
        <xsl:when test="tc:test-string">
          <xsl:sequence 
              select="$tctb:default-uri"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>I'm lost.</xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    
    <!--* If the input is given in the test catalog, we need to
        * write it out at the URI we specified for it. *-->
    <xsl:apply-templates select="tc:test-string"
                         mode="write-to-file">
      <xsl:with-param name="uri" select="$tctb:default-uri"/>
    </xsl:apply-templates>

    <!-- Assert:  uri of input string is in $uriS -->

    <!-- Where does the output go? -->
    <xsl:variable name="uriR">
      <xsl:sequence 
          select="concat(
                  if ($OUTDIR eq '')
                  then ''
                  else concat($OUTDIR, '/'),
                  'result.',
                  $idTC,
                  '.xml')"/>
    </xsl:variable>

    <xsl:variable name="command" select="concat(
                                         '    ', $CMD,
                                         ' ', $uriS,
                                         ' ', $uriG,
                                         ' ', $uriR
                                         )"/>

    <!-- tell the user what we know -->
    <xsl:if test="false()">
    <xsl:message>
      <xsl:text>    - Test case </xsl:text>
      <xsl:value-of select="$idTC"/>
    </xsl:message>
    </xsl:if>
    
    <!-- tell the bash file what we know -->
    <xsl:text>&#xA;#  - Test case </xsl:text>
    <xsl:value-of select="$idTC"/>
    <xsl:text> : </xsl:text>
    <!-- <xsl:value-of select="$command"/> -->
    
    <xsl:text>&#xA;echo "    - Test case </xsl:text>
    <xsl:value-of select="$idTC"/>
    <xsl:text>"</xsl:text>
    
    <!-- Add invocation of the command to the bash file -->
    <xsl:variable name="time-format" as="xs:string"
                  select="concat(
                          '&lt;tc:test-result',
                          ' name=\&quot;', $idTC, '\&quot;',
                          ' t:user-time=\&quot;%U\&quot;',
                          ' t:sys-time=\&quot;%S\&quot;',
                          ' t:clock-time=\&quot;%e\&quot;',
                          ' t:units=\&quot;sec\&quot;',
                          '/>'
                          )"/>
    
    <xsl:text>&#xA;/usr/bin/time </xsl:text>
    
    <xsl:text> -f </xsl:text>
    <xsl:value-of select="concat('&quot;', $time-format, '&quot;')"/>
    
    <xsl:text> -o </xsl:text>
    <xsl:value-of select="concat($OUTDIR, '/', $OUTPUT)"/>
    <xsl:text> -a </xsl:text>
    
    <xsl:value-of select="$command"/>

  </xsl:template>  

  <!--****************************************************************
      * 5.  Miscellaneous
      ****************************************************************
      *-->

  <!--* 5.1 write a file from an inline grammar or string *-->
  <xsl:template match="tc:ixml-grammar | tc:test-string"
                mode="write-to-file">
    <xsl:param name="uri" required="yes"/>

    <xsl:result-document href="{$uri}">
      <xsl:sequence select="string(.)"/>
    </xsl:result-document>
  </xsl:template>
  

  <!--* 5.2 translate a file: URI to a file path *-->
  <xsl:function name="tctb:uri-to-path"
                as="xs:string">
    <xsl:param name="uri" as="xs:string"/>

    <xsl:sequence select="if (starts-with($uri, 'file:///'))
                          then substring($uri, 8)
                          else if (starts-with($uri, 'file:/'))
                          then substring($uri, 6)
                          else $uri
                          "/>
  </xsl:function>

  
</xsl:stylesheet>
